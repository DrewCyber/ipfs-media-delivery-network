# Product Requirements Document: IPFS Media Collection Publisher

## 1. Overview

### 1.1 Purpose
Приложение на Go для автоматической публикации медиа-коллекций в IPFS с анонсированием через Pubsub. Приложение отслеживает указанные директории, загружает медиа-файлы в IPFS, создает индекс-файл с метаданными и публикует ссылку на коллекцию через IPNS и Pubsub.

### 1.2 Target Users
- Пользователи, желающие распространять медиа-коллекции через IPFS
- Хосты децентрализованных медиа-библиотек
- Контент-провайдеры в P2P сетях

## 2. Functional Requirements

### 2.1 File System Monitoring

#### 2.1.1 Мониторинг директорий
- Приложение отслеживает список директорий, указанных в конфигурации
- Рекурсивное сканирование поддиректорий
- Использование OS-level file system watcher (fsnotify библиотека для Go)
- Отслеживание событий:
  - Создание нового файла
  - Изменение существующего файла (modification time)
  - Удаление файла
  - Переименование файла

#### 2.1.2 Фильтрация файлов
- Обработка только файлов с расширениями из whitelist конфига
- Case-insensitive сравнение расширений
- Игнорирование скрытых файлов (начинающихся с `.`)
- Игнорирование временных файлов и системных директорий

#### 2.1.3 Определение изменений
- При обнаружении изменения файла проверка по:
  - Modification time (mtime)
  - Размеру файла
- Hash-сравнение не используется для оптимизации производительности

### 2.2 IPFS Integration

#### 2.2.1 Подключение к IPFS
- Подключение к IPFS ноде через HTTP API
- Параметры подключения из конфига (URL, порт)
- При недоступности ноды:
  - Логирование ошибки с уровнем ERROR
  - Повторные попытки подключения каждые 30 секунд
  - Приложение не завершается, ожидает доступности ноды

#### 2.2.2 Загрузка файлов в IPFS
- Последовательная загрузка файлов (один за другим)
- Поддержка параметров IPFS add:
  - `--nocopy` (опционально, из конфига)
  - `--pin` (опционально, из конфига)
  - Другие параметры через конфиг
- Получение CID для каждого загруженного файла
- Логирование процесса:
  - INFO: начало загрузки файла
  - INFO: успешная загрузка с CID
  - ERROR: ошибка загрузки с деталями

#### 2.2.3 Progress Tracking
- Отображение прогресс-бара при обработке большого количества файлов (>10)
- Информация в прогресс-баре:
  - Текущий обрабатываемый файл
  - Количество обработанных/общее количество
  - Процент выполнения
- Детальное логирование в файл параллельно с прогресс-баром

### 2.3 Collection Index Management

#### 2.3.1 Формат NDJSON файла
```json
{"id":1,"CID":"Qmd7EioyCPrbGMTry4XSXL82jnBNcUSTN5hkiVv96Pipxx","filename":"song.mp3","extension":"mp3"}
{"id":2,"CID":"Qmd7EioyCPrbGMTry4XSXL82jnBNcsdfasdfadfasdfasd","filename":"video.mkv","extension":"mkv"}
```

**Поля:**
- `id` (int): Порядковый номер записи (начинается с 1)
- `CID` (string): IPFS CID загруженного файла
- `filename` (string): Оригинальное имя файла
- `extension` (string): Расширение файла (без точки)

#### 2.3.2 Создание и обновление индекса
- При первом запуске создается пустой NDJSON файл
- При добавлении нового файла:
  - Новая запись добавляется в конец NDJSON
  - `id` присваивается следующий по порядку
- При изменении существующего файла:
  - Поиск записи по `filename`
  - Обновление только поля `CID`
  - `id` остается неизменным
- При удалении файла:
  - Удаление соответствующей строки из NDJSON
  - `id` других записей НЕ изменяются (могут быть пропуски в нумерации)
- При переименовании файла:
  - Обновление поля `filename` в существующей записи
  - Сохранение `id` и `CID`

#### 2.3.3 Загрузка индекса в IPFS
- После обновления NDJSON файл загружается в IPFS
- Получение нового CID для индекс-файла
- Pinning индекс-файла (если включено в конфиге)

### 2.4 IPNS Management

#### 2.4.1 Генерация ключей
- При первом запуске генерируется Ed25519 ключевая пара
- Ключи сохраняются локально в:
  - `~/.ipfs_publisher/keys/private.key`
  - `~/.ipfs_publisher/keys/public.key`
- При последующих запусках используются существующие ключи
- Один IPNS ключ на все приложение (все директории)

#### 2.4.2 Создание и обновление IPNS
- При первой публикации создается IPNS запись
- IPNS запись указывает на текущий CID индекс-файла
- При обновлении индекса:
  - IPNS запись обновляется новым CID
  - IPNS hash остается неизменным
- Время жизни IPNS записи: 24 часа
- IPNS запись подписывается приватным ключом

### 2.5 Pubsub Announcement

#### 2.5.1 Формат сообщения
```json
{
  "version": 3,
  "ipns": "k51qzi5uqu5dh9ihj8p0dxgzm4jw8m8q9tqxm...",
  "publicKey": "CAASogEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC...",
  "collectionSize": 60,
  "timestamp": 1700000000,
  "signature": "base64_encoded_signature"
}
```

**Поля:**
- `version` (int): Счетчик обновлений (инкрементируется при каждом изменении коллекции)
- `ipns` (string): IPNS хеш, указывающий на актуальную версию индекса
- `publicKey` (string): Base64-encoded публичный ключ для верификации
- `collectionSize` (int): Количество записей в NDJSON файле
- `timestamp` (int): Unix timestamp в секундах
- `signature` (string): Base64-encoded подпись сообщения приватным ключом

#### 2.5.2 Подписывание сообщений
- Подпись создается от JSON объекта без поля `signature`
- Алгоритм: Ed25519
- Подпись в формате Base64
- Получатели могут верифицировать подпись используя `publicKey`

#### 2.5.3 Публикация в Pubsub
- Топик: настраивается в конфиге (по умолчанию `mdn/collections/announce`)
- Публикация происходит:
  - При первой загрузке всех файлов
  - После каждого обновления коллекции
  - Каждый час (независимо от изменений)
- При ошибке публикации:
  - Логирование с уровнем ERROR
  - Ожидание следующей попытки (через час или при следующем изменении)
  - Приложение продолжает работу

#### 2.5.4 Периодические анонсы
- Таймер: каждые 60 минут
- Публикуется текущее состояние коллекции
- `version` не инкрементируется, если коллекция не изменилась
- `timestamp` остается неизменным (время последнего реального обновления коллекции)

### 2.6 State Persistence

#### 2.6.1 Локальное состояние
Файл состояния: `~/.ipfs_publisher/state.json`

```json
{
  "version": 15,
  "ipns": "k51qzi5uqu5dh9ihj8p0dxgzm4jw8m8q9tqxm...",
  "lastIndexCID": "QmXyZ...",
  "files": {
    "/path/to/file1.mp3": {
      "cid": "QmAbc...",
      "mtime": 1700000000,
      "size": 5242880,
      "indexId": 1
    },
    "/path/to/file2.mkv": {
      "cid": "QmDef...",
      "mtime": 1700000100,
      "size": 104857600,
      "indexId": 2
    }
  }
}
```

#### 2.6.2 Восстановление после перезапуска
- При запуске приложение загружает `state.json`
- Сканирование директорий для определения изменений:
  - Новые файлы (отсутствуют в state)
  - Измененные файлы (mtime или size отличается)
  - Удаленные файлы (есть в state, но отсутствуют на диске)
- Обработка только измененных файлов
- Обновление state после обработки

#### 2.6.3 Обработка прерванной заливки
- Если файл был в процессе заливки при падении приложения:
  - Файл отсутствует в state или имеет пустой CID
  - При перезапуске файл помечается для повторной обработки
- Проверка целостности индекса при запуске

### 2.7 Error Handling

#### 2.7.1 IPFS недоступен
- Ожидание с периодическими попытками подключения (30 сек)
- Очередь файлов для обработки накапливается
- После восстановления связи обработка очереди

#### 2.7.2 Файл удален во время обработки
- Ловим ошибку "file not found" при чтении/загрузке
- Удаляем файл из очереди обработки
- Удаляем запись из NDJSON, если она там была
- Обновляем индекс и публикуем изменения

#### 2.7.3 Недостаточно места на диске
- Проверка доступного места перед обработкой больших файлов
- Если места недостаточно:
  - ERROR лог с предупреждением
  - Пропуск файла
  - Продолжение работы с другими файлами

#### 2.7.4 Некорректные права доступа
- Ловим ошибки "permission denied"
- Логирование с указанием проблемного файла
- Пропуск файла, продолжение работы

## 3. Configuration

### 3.1 Конфигурационный файл
Формат: YAML
Путь по умолчанию: `./config.yaml` или `~/.ipfs_publisher/config.yaml`

```yaml
# IPFS connection settings
ipfs:
  api_url: "http://localhost:5001"
  timeout: 300  # seconds
  add_options:
    nocopy: false
    pin: true
    chunker: "size-262144"
    raw_leaves: true

# Directories to monitor
directories:
  - "/path/to/media1"
  - "/path/to/media2"
  - "/home/user/music"

# File extensions to process (case-insensitive)
extensions:
  - "mp3"
  - "mp4"
  - "mkv"
  - "avi"
  - "flac"
  - "wav"

# Pubsub settings
pubsub:
  topic: "mdn/collections/announce"
  announce_interval: 3600  # seconds (1 hour)

# Logging
logging:
  level: "info"  # debug, info, warn, error
  file: "~/.ipfs_publisher/logs/app.log"
  max_size: 100  # MB
  max_backups: 5
  console: true

# Application behavior
behavior:
  scan_interval: 10  # seconds, how often to check for changes
  batch_size: 10  # files to process in one batch
  progress_bar: true
  state_save_interval: 60  # seconds
```

### 3.2 Command Line Arguments
```bash
ipfs-publisher [flags]

Flags:
  -c, --config string     Path to config file (default "./config.yaml")
  -v, --version          Show version information
  -h, --help             Show help message
  --init                 Initialize configuration and generate keys
  --check-ipfs           Check IPFS connection and exit
  --dry-run              Scan and show what would be processed without uploading
```

## 4. Technical Architecture

### 4.1 Technology Stack
- **Language**: Go 1.21+
- **IPFS Integration**: 
  - `github.com/ipfs/go-ipfs-api` (HTTP API client)
  - или `github.com/ipfs/kubo` (для опциональной встроенной ноды)
- **File System Monitoring**: `github.com/fsnotify/fsnotify`
- **Logging**: `github.com/sirupsen/logrus` или `go.uber.org/zap`
- **Configuration**: `github.com/spf13/viper`
- **Progress Bar**: `github.com/schollz/progressbar`
- **Cryptography**: `crypto/ed25519` (стандартная библиотека)

### 4.2 Application Components

#### 4.2.1 Main Components
1. **FileWatcher**: Мониторинг файловой системы
2. **IPFSClient**: Взаимодействие с IPFS API
3. **IndexManager**: Управление NDJSON индексом
4. **IPNSManager**: Создание и обновление IPNS записей
5. **PubsubPublisher**: Публикация анонсов в Pubsub
6. **StateManager**: Сохранение и восстановление состояния
7. **KeyManager**: Генерация и управление ключами

#### 4.2.2 Data Flow
```
FileWatcher → IPFSClient → IndexManager → IPNSManager → PubsubPublisher
                ↓                                            ↓
           StateManager ←─────────────────────────────────────┘
```

### 4.3 Concurrency Model
- Основной goroutine для FileWatcher
- Отдельный goroutine для периодических Pubsub анонсов
- Worker pool (опционально) для параллельной загрузки в IPFS
- Channels для координации между компонентами
- Mutex для защиты shared state

### 4.4 Performance Considerations

#### 4.4.1 Оптимизация для больших коллекций
- Инкрементальное обновление индекса (не пересканирование всех файлов)
- Кеширование CID для неизмененных файлов
- Batch processing для множественных изменений
- Debouncing для частых изменений файлов (300ms)

#### 4.4.2 Memory Management
- Streaming upload для больших файлов (>100MB)
- Ограничение размера буфера при чтении индекса
- Периодическая очистка кеша состояния

## 5. Security Considerations

### 5.1 Key Management
- Приватные ключи хранятся с правами доступа 0600
- Директория ключей: 0700
- Опциональное шифрование ключей паролем (future enhancement)

### 5.2 Input Validation
- Валидация путей директорий (защита от path traversal)
- Проверка максимального размера файлов
- Валидация расширений файлов
- Санитизация имен файлов в индексе

### 5.3 IPFS Security
- Опциональная аутентификация к IPFS API
- Проверка TLS сертификатов при HTTPS
- Rate limiting для защиты от DoS

## 6. Monitoring and Observability

### 6.1 Logging Levels
- **DEBUG**: Детальная информация о каждой операции
- **INFO**: Основные события (файл обработан, индекс обновлен)
- **WARN**: Потенциальные проблемы (замедление обработки)
- **ERROR**: Ошибки, не прерывающие работу приложения

### 6.2 Metrics (опционально)
- Количество обработанных файлов
- Размер загруженных данных
- Время обработки файлов
- Количество ошибок по типам
- Доступность IPFS ноды

### 6.3 Health Checks
- Проверка подключения к IPFS
- Проверка доступности директорий
- Проверка целостности state файла
- Endpoint для проверки статуса (опционально)

## 7. Testing Strategy

### 7.1 Unit Tests
- Тесты для каждого компонента изолированно
- Mock IPFS API для тестирования IPFSClient
- Тесты для корректности подписывания/верификации

### 7.2 Integration Tests
- Тесты с реальной IPFS нодой (testnet)
- Тесты сценариев изменения файлов
- Тесты восстановления после сбоев

### 7.3 Performance Tests
- Тесты с большими коллекциями (10000+ файлов)
- Тесты с большими файлами (>1GB)
- Memory leak тесты при длительной работе

## 8. Future Enhancements

### 8.1 Potential Features
- Поддержка множественных IPNS ключей (отдельный на директорию)
- Web UI для мониторинга
- Поддержка удаленных директорий (SFTP, S3)
- Автоматическая очистка старых версий из IPFS
- Метаданные файлов (теги, описания)
- Поддержка плейлистов и альбомов

### 8.2 Optimization Opportunities
- Параллельная загрузка файлов в IPFS
- Дедупликация файлов по content hash
- Compression для индекс-файла
- Incremental IPNS updates

## 9. Edge Cases and Limitations

### 9.1 Known Limitations
- Максимальный размер индекс-файла: ~100MB (ограничение IPFS block size)
- Не поддерживается версионирование удаленных файлов
- Нет автоматической ротации IPNS ключей
- Нет built-in репликации на другие IPFS ноды

### 9.2 Edge Cases
- **Быстрые множественные изменения**: Debouncing 300ms
- **Циклические symlinks**: Игнорируются при сканировании
- **Очень длинные имена файлов**: Обрезание до 255 символов
- **Специальные символы в именах**: URL encoding в индексе
- **Duplicate filenames в разных директориях**: Добавление относительного пути в filename

## 10. Acceptance Criteria

### 10.1 Functional
- ✓ Приложение корректно обрабатывает добавление новых файлов
- ✓ Изменение файла приводит к обновлению его CID в индексе
- ✓ Удаление файла удаляет его из индекса
- ✓ IPNS корректно обновляется при изменениях
- ✓ Pubsub сообщения публикуются каждый час
- ✓ Приложение восстанавливает состояние после перезапуска

### 10.2 Non-Functional
- ✓ Обработка 1000 файлов занимает < 5 минут (при --nocopy)
- ✓ Memory usage < 500MB при 10000 файлах
- ✓ Приложение восстанавливается после недоступности IPFS < 1 минута
- ✓ 99.9% uptime при непрерывной работе 30 дней

## 11. Риски и слабые места логики

### 11.1 Критические риски
1. **Race condition при быстром изменении файлов**
   - Проблема: Файл может измениться во время загрузки в IPFS
   - Решение: Проверка mtime после загрузки, повторная обработка при расхождении

2. **Потеря данных при падении между обновлением индекса и state**
   - Проблема: State сохраняется не атомарно с IPFS операциями
   - Решение: Не критично. При перезапуске приложение пересканирует директории и обнаружит несоответствия

3. **Конфликты при одновременном запуске нескольких экземпляров**
   - Проблема: Два экземпляра могут обрабатывать одни файлы
   - Решение: Lock file (`~/.ipfs_publisher/.lock`) с PID проверкой для предотвращения множественных запусков

### 11.2 Проблемы масштабирования
1. **NDJSON файл растет бесконечно**
   - Проблема: При десятках тысяч файлов индекс будет огромным (потенциально >100MB)
   - Риск: IPFS block size limit, медленная загрузка/обработка индекса
   - Решение: Мониторинг размера индекса. При превышении порога (например, 50MB) рассмотреть разбиение на множественные индексы или переход на другой формат (например, SQLite в IPFS)

2. **Memory spike при загрузке большого индекса**
   - Проблема: Весь NDJSON загружается в память для обновления
   - Решение: Streaming парсинг и построчная обработка/обновление индекса

3. **Version counter overflow**
   - Проблема: При длительной работе и частых обновлениях int может переполниться
   - Решение: Использование uint64 (достаточно для ~18 квинтиллионов обновлений)

### 11.3 Проблемы надежности
1. **IPNS republish может не успеть за изменениями**
   - Проблема: IPNS имеет TTL 24 часа, может устареть между обновлениями
   - Решение: Периодический refresh IPNS (каждые 12 часов) даже без изменений коллекции

2. **Pubsub сообщения не гарантируют доставку**
   - Проблема: Получатели могут пропустить анонсы
   - Решение: Это ожидаемое поведение Pubsub. Часовые повторы компенсируют пропущенные сообщения

3. **Отсутствие верификации успешности загрузки в IPFS**
   - Проблема: IPFS API может вернуть CID, но данные могут быть повреждены или не полностью записаны
   - Решение: Доверяем IPFS API. В случае проблем пользователь может включить опциональную верификацию через повторное чтение файла из IPFS (будущая функциональность)

### 11.4 Проблемы UX
1. **Нет индикации прогресса при первом запуске**
   - Проблема: Пользователь не видит, что происходит
   - Решение: Детальный прогресс-бар с ETA

2. **Непонятно, почему файл не обрабатывается**
   - Проблема: Файл может игнорироваться по разным причинам (расширение, права)
   - Решение: Явные WARNING логи для игнорируемых файлов

### 11.5 Проблемы безопасности
1. **Публичный ключ в Pubsub может быть подделан**
   - Проблема: Злоумышленник может опубликовать свой publicKey
   - Решение: Получатели должны иметь whitelist доверенных ключей

2. **Нет защиты от spam в Pubsub**
   - Проблема: Злоумышленник может флудить топик
   - Решение: Rate limiting на стороне получателей

### 11.6 Операционные риски
1. **Нет автоматической очистки старых CID из IPFS**
   - Проблема: IPFS ноде грозит переполнение при частых обновлениях
   - Решение: Периодический garbage collection или unpinning старых версий

2. **Сложность debugging при проблемах с IPFS**
   - Проблема: Ошибки IPFS API могут быть неинформативными
   - Решение: Подробное логирование всех IPFS операций с request/response

## 12. Рекомендации по устранению слабых мест

### 12.1 Высокий приоритет (MVP)
1. Добавить lock file для предотвращения множественных запусков
2. Реализовать проверку целостности (mtime check после upload)
3. Использовать uint64 для version counter
4. Реализовать graceful shutdown с сохранением state

### 12.2 Средний приоритет (v1.1)
1. Реализовать streaming обработку индекса для больших коллекций
2. Добавить мониторинг размера индекс-файла с предупреждениями
3. Добавить retry logic с exponential backoff для IPFS операций
4. Реализовать периодический IPNS refresh (каждые 12 часов)

### 12.3 Низкий приоритет (future)
1. Опциональная верификация загруженных файлов (через config flag)
2. Chunked индексы для коллекций >100k файлов
3. Добавить metrics и monitoring
4. Реализовать автоматический garbage collection старых CID
5. Добавить web UI для мониторинга

## 13. План реализации по этапам

### Этап 1: Базовая структура и конфигурация (1-2 дня)
**Цель**: Настроить проект, конфигурацию и базовые компоненты

**Задачи:**
1. Инициализация Go модуля и структуры проекта
2. Реализация загрузки конфигурации (YAML)
3. Настройка логирования (файл + консоль)
4. Реализация lock file механизма
5. Базовая CLI структура с флагами

**Структура проекта:**
```
ipfs-publisher/
├── cmd/
│   └── ipfs-publisher/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── logger/
│   │   └── logger.go
│   └── lockfile/
│       └── lockfile.go
├── config.yaml
└── go.mod
```

**Ручное тестирование:**
```bash
# Тест 1: Запуск с конфигом
./ipfs-publisher --config ./config.yaml

# Тест 2: Проверка lock file
./ipfs-publisher  # первый экземпляр
./ipfs-publisher  # второй экземпляр должен завершиться с ошибкой

# Тест 3: Проверка логирования
cat ~/.ipfs_publisher/logs/app.log

# Тест 4: Валидация конфига
./ipfs-publisher --config invalid.yaml  # должна быть ошибка
```

**Критерии готовности:**
- ✓ Приложение запускается и читает конфиг
- ✓ Логи пишутся в файл и консоль
- ✓ Второй экземпляр не может запуститься
- ✓ Graceful shutdown по Ctrl+C

---

### Этап 2: IPFS клиент и базовые операции (2-3 дня)
**Цель**: Подключиться к IPFS и реализовать загрузку файлов

**Задачи:**
1. Создать IPFSClient компонент
2. Реализовать подключение к IPFS API
3. Реализовать функцию добавления файла в IPFS
4. Обработка ошибок и retry логика
5. Поддержка параметров --nocopy и --pin

**Новые файлы:**
```
internal/
├── ipfs/
│   ├── client.go
│   └── options.go
```

**Ручное тестирование:**
```bash
# Подготовка: запустить IPFS daemon
ipfs daemon

# Тест 1: Проверка подключения
./ipfs-publisher --check-ipfs
# Ожидается: "✓ Connected to IPFS node at http://localhost:5001"

# Тест 2: Загрузка одного файла (добавить test команду)
./ipfs-publisher --test-upload /path/to/test.mp3
# Ожидается: "Uploaded: test.mp3 -> QmXxx..."

# Тест 3: Проверка --nocopy режима
./ipfs-publisher --test-upload /path/to/test.mp3 --nocopy
# Ожидается: успешная загрузка с флагом nocopy

# Тест 4: Проверка обработки недоступности IPFS
# Остановить IPFS daemon
./ipfs-publisher --check-ipfs
# Ожидается: попытки переподключения каждые 30 сек

# Тест 5: Проверка pinning
./ipfs-publisher --test-upload /path/to/test.mp3
ipfs pin ls | grep QmXxx
# Ожидается: файл в списке pinned
```

**Критерии готовности:**
- ✓ Успешное подключение к IPFS API
- ✓ Файлы загружаются и возвращают CID
- ✓ Работает режим --nocopy
- ✓ Работает pinning
- ✓ Приложение ждет появления IPFS при его недоступности

---

### Этап 3: Сканирование директорий и создание индекса (2-3 дня)
**Цель**: Сканировать директории и создавать NDJSON индекс

**Задачи:**
1. Реализовать сканирование директорий
2. Фильтрация по расширениям
3. Создание NDJSON индекса
4. Загрузка всех файлов в IPFS
5. Прогресс-бар для большого количества файлов

**Новые файлы:**
```
internal/
├── scanner/
│   └── scanner.go
├── index/
│   ├── manager.go
│   └── ndjson.go
```

**Ручное тестирование:**
```bash
# Подготовка: создать тестовую директорию
mkdir -p ~/test-media
cp some-files.mp3 ~/test-media/
cp some-video.mkv ~/test-media/

# Обновить config.yaml:
# directories:
#   - "~/test-media"
# extensions:
#   - "mp3"
#   - "mkv"

# Тест 1: Первичное сканирование (dry-run режим)
./ipfs-publisher --dry-run
# Ожидается: список найденных файлов без загрузки

# Тест 2: Загрузка всех файлов
./ipfs-publisher
# Ожидается:
# - Прогресс-бар с процентом
# - Логи для каждого файла
# - Создание ~/.ipfs_publisher/collection.ndjson

# Тест 3: Проверка содержимого индекса
cat ~/.ipfs_publisher/collection.ndjson
# Ожидается:
# {"id":1,"CID":"QmXxx...","filename":"file1.mp3","extension":"mp3"}
# {"id":2,"CID":"QmYyy...","filename":"file2.mkv","extension":"mkv"}

# Тест 4: Проверка фильтрации
touch ~/test-media/ignored.txt
./ipfs-publisher --dry-run
# Ожидается: ignored.txt не в списке

# Тест 5: Множественные директории
# Добавить в config.yaml еще одну директорию
./ipfs-publisher
# Ожидается: файлы из обеих директорий в одном индексе

# Тест 6: Обработка большого количества файлов
# Скопировать 100+ файлов
./ipfs-publisher
# Ожидается: работающий прогресс-бар с ETA
```

**Критерии готовности:**
- ✓ Все файлы из директорий найдены
- ✓ Фильтрация по расширениям работает
- ✓ NDJSON индекс создан корректно
- ✓ Все файлы загружены в IPFS с правильными CID
- ✓ Прогресс-бар отображается корректно

---

### Этап 4: IPNS и управление ключами (2 дня)
**Цель**: Генерировать ключи и публиковать индекс через IPNS

**Задачи:**
1. Генерация Ed25519 ключевой пары
2. Сохранение ключей на диск
3. Загрузка индекс-файла в IPFS
4. Создание IPNS записи
5. Обновление IPNS при изменениях

**Новые файлы:**
```
internal/
├── keys/
│   └── manager.go
├── ipns/
│   └── manager.go
```

**Ручное тестирование:**
```bash
# Тест 1: Генерация ключей при первом запуске
rm -rf ~/.ipfs_publisher/keys
./ipfs-publisher
# Ожидается:
# - Создание ~/.ipfs_publisher/keys/private.key
# - Создание ~/.ipfs_publisher/keys/public.key
# - Лог: "Generated new IPNS keypair"

# Тест 2: Использование существующих ключей
./ipfs-publisher
# Ожидается: "Loaded existing IPNS keypair"

# Тест 3: Проверка IPNS публикации
./ipfs-publisher
cat ~/.ipfs_publisher/state.json | jq .ipns
# Ожидается: IPNS hash вида "k51qzi5uqu5d..."

# Тест 4: Проверка резолва IPNS
IPNS_HASH=$(cat ~/.ipfs_publisher/state.json | jq -r .ipns)
ipfs name resolve $IPNS_HASH
# Ожидается: CID индекс-файла

# Тест 5: Получение индекса через IPNS
ipfs cat $IPNS_HASH
# Ожидается: содержимое NDJSON файла

# Тест 6: Обновление коллекции
cp new-file.mp3 ~/test-media/
./ipfs-publisher
ipfs name resolve $IPNS_HASH
# Ожидается: новый CID (индекс обновился)

# Тест 7: Проверка прав доступа к ключам
ls -la ~/.ipfs_publisher/keys/
# Ожидается: 
# -rw------- private.key (0600)
# -rw-r--r-- public.key (0644)
```

**Критерии готовности:**
- ✓ Ключи генерируются при первом запуске
- ✓ Ключи загружаются при последующих запусках
- ✓ Индекс загружается в IPFS
- ✓ IPNS запись создается и указывает на индекс
- ✓ IPNS обновляется при изменении коллекции
- ✓ Правильные права доступа к файлам ключей

---

### Этап 5: Pubsub публикация (1-2 дня)
**Цель**: Публиковать анонсы в Pubsub

**Задачи:**
1. Создание Pubsub сообщения с подписью
2. Публикация в топик
3. Периодическая публикация (каждый час)
4. Инкремент version counter

**Новые файлы:**
```
internal/
├── pubsub/
│   ├── publisher.go
│   └── message.go
```

**Ручное тестирование:**
```bash
# Тест 1: Подписка на топик (в отдельном терминале)
ipfs pubsub sub mdn/collections/announce

# Тест 2: Первая публикация
# В основном терминале:
./ipfs-publisher
# В терминале с подпиской ожидается сообщение:
# {
#   "version": 1,
#   "ipns": "k51qzi5uqu5d...",
#   "publicKey": "CAAS...",
#   "collectionSize": 5,
#   "timestamp": 1700000000,
#   "signature": "base64..."
# }

# Тест 3: Проверка подписи
# Создать тестовый скрипт для верификации подписи
./verify-signature.sh <pubsub_message>
# Ожидается: "✓ Signature valid"

# Тест 4: Добавление файла и публикация
cp another.mp3 ~/test-media/
# Ожидается в pubsub:
# {"version": 2, "collectionSize": 6, ...}

# Тест 5: Периодическая публикация
# Ждать 1 час (или изменить interval в коде на 1 минуту для теста)
# Ожидается в pubsub через час:
# {"version": 2, "collectionSize": 6, ...}  # version не изменился

# Тест 6: Проверка timestamp
# При повторной публикации без изменений
# timestamp должен остаться прежним

# Тест 7: Обработка ошибки pubsub
# Остановить IPFS daemon
# Подождать момента публикации
# Ожидается: ERROR лог, но приложение продолжает работать
```

**Критерии готовности:**
- ✓ Сообщения публикуются в правильный топик
- ✓ Формат сообщения соответствует спецификации
- ✓ Подпись корректна и может быть верифицирована
- ✓ Version инкрементируется при изменениях
- ✓ Timestamp не меняется при повторных публикациях
- ✓ Периодические публикации работают (каждый час)

---

### Этап 6: File System Watcher и инкрементальные обновления (2-3 дня)
**Цель**: Отслеживать изменения файлов в реальном времени

**Задачи:**
1. Интеграция fsnotify
2. Обработка событий create/modify/delete/rename
3. Инкрементальное обновление индекса
4. Debouncing для частых изменений
5. Обновление state

**Новые файлы:**
```
internal/
├── watcher/
│   └── watcher.go
├── state/
│   └── manager.go
```

**Ручное тестирование:**
```bash
# Тест 1: Запуск в режиме мониторинга
./ipfs-publisher
# Приложение продолжает работать, мониторит директории

# Тест 2: Добавление нового файла
# В другом терминале:
cp new-song.mp3 ~/test-media/
# Ожидается:
# - Лог: "Detected new file: new-song.mp3"
# - Загрузка в IPFS
# - Обновление NDJSON
# - Обновление IPNS
# - Pubsub публикация с version=3

# Тест 3: Изменение существующего файла
echo "updated" >> ~/test-media/existing.mp3
# Ожидается:
# - Лог: "Detected change: existing.mp3"
# - Повторная загрузка в IPFS
# - Обновление CID в NDJSON
# - version=4

# Тест 4: Удаление файла
rm ~/test-media/old-file.mp3
# Ожидается:
# - Лог: "Detected deletion: old-file.mp3"
# - Удаление записи из NDJSON
# - Обновление индекса
# - version=5

# Тест 5: Переименование файла
mv ~/test-media/song.mp3 ~/test-media/renamed-song.mp3
# Ожидается:
# - Обновление filename в NDJSON
# - Сохранение id и CID
# - version=6

# Тест 6: Быстрые множественные изменения (debouncing)
for i in {1..10}; do
  echo "change $i" >> ~/test-media/test.mp3
  sleep 0.1
done
# Ожидается:
# - Только одна обработка файла (после debounce периода)
# - version увеличился только на 1

# Тест 7: Проверка state файла
cat ~/.ipfs_publisher/state.json | jq .
# Ожидается корректная структура с актуальными данными

# Тест 8: Восстановление после перезапуска
./ipfs-publisher  # запустить
# Добавить файл
cp test.mp3 ~/test-media/
# Ждать обработки
killall ipfs-publisher  # прервать
./ipfs-publisher  # перезапустить
# Ожидается:
# - Лог: "Restored state: X files"
# - Проверка актуальности файлов
# - Обработка новых/измененных

# Тест 9: Игнорирование временных файлов
echo "test" > ~/test-media/.hidden
echo "test" > ~/test-media/file.tmp
# Ожидается: файлы игнорируются (нет в логах)
```

**Критерии готовности:**
- ✓ Новые файлы автоматически обрабатываются
- ✓ Изменения файлов обнаруживаются и обрабатываются
- ✓ Удаления файлов обрабатываются корректно
- ✓ Переименования обновляют существующие записи
- ✓ Debouncing предотвращает избыточную обработку
- ✓ State сохраняется и восстанавливается
- ✓ Приложение работает стабильно в течение длительного времени

---

### Этап 7: Финальная полировка и тестирование (1-2 дня)
**Цель**: Улучшить UX и покрыть edge cases

**Задачи:**
1. Улучшить логирование и сообщения об ошибках
2. Добавить справку и документацию
3. Обработка edge cases
4. Тестирование на больших коллекциях
5. Performance optimization

**Ручное тестирование:**
```bash
# Тест 1: Справка
./ipfs-publisher --help
# Ожидается: понятное описание всех флагов

# Тест 2: Инициализация конфига
./ipfs-publisher --init
# Ожидается: создание config.yaml с примерами

# Тест 3: Обработка специальных символов в именах файлов
touch ~/test-media/"file with spaces.mp3"
touch ~/test-media/"файл-кириллица.mp3"
touch ~/test-media/"file'with\"quotes.mp3"
./ipfs-publisher
# Ожидается: все файлы обработаны корректно

# Тест 4: Очень длинные имена файлов
touch ~/test-media/"$(printf 'a%.0s' {1..300}).mp3"
./ipfs-publisher
# Ожидается: имя обрезано до 255 символов

# Тест 5: Symlinks
ln -s ~/other-dir ~/test-media/symlink-dir
./ipfs-publisher --dry-run
# Ожидается: symlinks игнорируются

# Тест 6: Большая коллекция (стресс-тест)
# Создать 1000+ файлов
for i in {1..1000}; do
  touch ~/test-media/file-$i.mp3
done
./ipfs-publisher
# Проверить:
# - Memory usage (должен быть < 500MB)
# - CPU usage
# - Время обработки
# - Корректность индекса

# Тест 7: Работа в течение длительного времени
./ipfs-publisher
# Оставить на 24 часа
# Периодически добавлять/изменять файлы
# Проверить:
# - Нет memory leaks
# - Pubsub публикации каждый час
# - Логи не переполнены

# Тест 8: Graceful shutdown
./ipfs-publisher
# Ctrl+C во время обработки файла
# Ожидается:
# - "Shutting down gracefully..."
# - State сохранен
# - Lock file удален

# Тест 9: Все логи понятны
./ipfs-publisher --log-level debug
# Проверить, что логи:
# - Имеют правильный уровень
# - Содержат достаточно контекста
# - Не содержат чувствительных данных

# Тест 10: Итоговый smoke test
rm -rf ~/.ipfs_publisher
./ipfs-publisher --init
# Отредактировать config.yaml
./ipfs-publisher
# Ожидается полный цикл работы без ошибок
```

**Критерии готовности:**
- ✓ Все edge cases обработаны
- ✓ Логи понятны и информативны
- ✓ Документация актуальна
- ✓ Performance приемлемый для больших коллекций
- ✓ Нет memory leaks
- ✓ Graceful shutdown работает корректно

---

## 14. Итоговый чеклист готовности к продакшену

### Функциональность
- [ ] Сканирование множественных директорий
- [ ] Фильтрация по расширениям
- [ ] Загрузка файлов в IPFS
- [ ] Создание NDJSON индекса
- [ ] IPNS публикация
- [ ] Pubsub анонсы
- [ ] Реал-тайм мониторинг изменений
- [ ] Инкрементальные обновления
- [ ] Сохранение и восстановление состояния

### Надежность
- [ ] Lock file предотвращает множественные запуски
- [ ] Graceful shutdown
- [ ] Обработка недоступности IPFS
- [ ] Retry logic для IPFS операций
- [ ] Обработка удаления файлов во время обработки
- [ ] Корректное восстановление после краша

### UX
- [ ] Прогресс-бар для больших коллекций
- [ ] Понятные логи
- [ ] --help с документацией
- [ ] --dry-run для тестирования
- [ ] --init для инициализации
- [ ] Конфигурация через YAML

### Безопасность
- [ ] Правильные права доступа к ключам (0600)
- [ ] Подписи pubsub сообщений
- [ ] Валидация путей файлов
- [ ] Санитизация имен файлов

### Performance
- [ ] < 500MB памяти при 10k файлов
- [ ] Debouncing для частых изменений
- [ ] Streaming обработка больших индексов
- [ ] Нет memory leaks

### Документация
- [ ] README с примерами
- [ ] Описание формата конфига
- [ ] Troubleshooting guide
- [ ] Примеры использования