# Техническое задание (PRD): Публикатор медиа-коллекций в IPFS

## 1. Обзор

### 1.1 Назначение
Приложение на Go для автоматической публикации медиа-коллекций в IPFS с анонсированием через PubSub. Приложение отслеживает указанные директории, загружает медиа-файлы в IPFS, формирует файл-индекс с метаданными и публикует ссылку на коллекцию через IPNS и PubSub.

### 1.2 Целевая аудитория
- Пользователи, желающие распространять медиа-коллекции через IPFS
- Хосты децентрализованных медиабиблиотек
- Поставщики контента в P2P сетях

## 2. Функциональные требования

### 2.1 Мониторинг файловой системы

#### 2.1.1 Наблюдение за директориями
- Приложение следит за списком директорий, заданных в конфиге
- Рекурсивное сканирование поддиректорий
- Использовать системный watcher файловой системы (`fsnotify` для Go)
- Отслеживать события:
  - Создание нового файла
  - Изменение существующего файла (mtime)
  - Удаление файла
  - Переименование файла

#### 2.1.2 Фильтрация файлов
- Обрабатывать только файлы с расширениями из whitelist в конфиге
- Сравнение расширений без учета регистра
- Игнорировать скрытые файлы (начинаются с `.`)
- Игнорировать временные файлы и системные директории

#### 2.1.3 Определение изменений
- При обнаружении изменения файла проверять по:
  - Времени модификации (mtime)
  - Размеру файла
- Сравнение хешей не используется для оптимизации производительности

### 2.2 Интеграция с IPFS

#### 2.2.1 Режимы работы IPFS

Приложение поддерживает два режима работы IPFS:

**Внешний режим (по умолчанию):**
- Подключение к существующему IPFS-узлу (например, IPFS Desktop или kubo daemon)
- Использование HTTP API для операций (add, pin, get)
- Рекомендуется, если у пользователя уже есть IPFS-узел

**Встроенный режим:**
- Запуск полного IPFS-узла внутри приложения
- Полный функционал IPFS: DHT, bitswap, content routing
- Используется если у пользователя нет внешнего узла или нужен изолированный узел

**PubSub провайдер:**
- Всегда использует встроенную реализацию PubSub независимо от режима IPFS
- Причина: IPFS Desktop убрал PubSub-эндпоинт из HTTP API
- Встроенный PubSub запускается даже в режиме external

**Выбор режима:**
- Задается в конфиге (жёстко)
- Пользователь явно выбирает режим
- Автоматического переключения режимов нет

#### 2.2.2 Подключение к внешнему IPFS
- Подключение к IPFS через HTTP API
- Параметры подключения из конфига (URL, порт)
- Если узел недоступен:
  - Логирование ERROR
  - Повторные попытки каждые 30 секунд
  - Приложение ждет доступности узла, не завершается

#### 2.2.3 Встроенный IPFS-узел

**Инициализация:**
- При первом запуске инициализировать репозиторий IPFS в `~/.ipfs_publisher/ipfs-repo`
- Сгенерировать peer identity (ключи)
- Использовать стандартные bootstrap-ноды для DHT
- Репозиторий сохраняется между запусками

**Конфигурация:**
- Переопределяемые порты, чтобы избежать конфликтов с внешним узлом
- Настраиваемые swarm, API и gateway порты
- По умолчанию использовать порты, отличные от стандартных (4001, 5001, 8080)

**Проверки перед запуском:**
- До старта проверить доступность конфигурируемых портов
- Если порт занят:
  - Логировать ERROR: "Port {port} is already in use..."
  - Завершить приложение с ненулевым кодом
  - Подсказать проверить `ipfs id` или `lsof -i :{port}`

**Жизненный цикл:**
- Запуск встроенного узла при старте приложения
- Грейсфул-остановка при завершении приложения
- Ожидать завершения операций перед остановкой

**Функциональность:**
- Полная функциональность IPFS
- Участие в DHT
- Bitswap
- Pinning и хранение контента
- Garbage collection опционально

#### 2.2.4 Загрузка файлов в IPFS
- Загружать файлы последовательно
- Использовать активный IPFS-узел (external или embedded)
- Поддерживать опции add:
  - `--nocopy` (только для external с filestore)
  - `--pin`
  - `--chunker`
  - `--raw-leaves`
  - Другие опции через конфиг
- Получать CID для каждого файла
- Логировать:
  - INFO: начало загрузки файла
  - INFO: успешная загрузка и CID
  - ERROR: ошибка загрузки с деталями

#### 2.2.5 Отслеживание прогресса
- Показывать прогресс-бар при обработке большого числа файлов (>10)
- Информация в прогресс-баре:
  - Текущий файл
  - Обработано/всего
  - Процент
  - Индикатор текущего режима IPFS
- Детальные логи пишутся в файл параллельно

### 2.3 Управление индексом коллекции

#### 2.3.1 Формат NDJSON
```json
{"id":1,"CID":"Qmd7EioyCPrbGMTry4XSXL82jnBNcUSTN5hkiVv96Pipxx","filename":"song.mp3","extension":"mp3"}
{"id":2,"CID":"Qmd7EioyCPrbGMTry4XSXL82jnBNcsdfasdfadfasdfasd","filename":"video.mkv","extension":"mkv"}
```

**Поля:**
- `id` (int): последовательный номер записи (начинается с 1)
- `CID` (string): IPFS CID загруженного файла
- `filename` (string): оригинальное имя файла
- `extension` (string): расширение без точки

#### 2.3.2 Создание и обновление индекса
- При первом запуске создать пустой NDJSON
- При добавлении файла:
  - Добавить новую запись в конец
  - `id` = следующий по порядку
- При изменении существующего файла:
  - Найти запись по `filename`
  - Обновить только `CID`
  - `id` не меняется
- При удалении файла:
  - Удалить соответствующую строку
  - `id` других записей НЕ изменяются (возможны пропуски)
- При переименовании:
  - Обновить `filename` в записи
  - Сохранить `id` и `CID`

#### 2.3.3 Загрузка индекса в IPFS
- После обновления NDJSON загрузить файл в IPFS
- Использовать активный IPFS-узел
- Получить CID индексного файла
- При необходимости закрепить (pin)

### 2.4 Управление IPNS

#### 2.4.1 Генерация ключей
- При первом запуске сгенерировать пару Ed25519
- Ключи сохраняются в:
  - `~/.ipfs_publisher/keys/private.key`
  - `~/.ipfs_publisher/keys/public.key`
- При последующих запусках использовать существующие ключи
- Один IPNS-ключ для всего приложения

#### 2.4.2 Создание и обновление IPNS
- При первой публикации создать запись IPNS
- Запись IPNS указывает на текущий CID индекс-файла
- Использовать активный IPFS-узел для IPNS-операций
- При обновлениях индекса:
  - Обновлять IPNS на новый CID
  - IPNS-хеш остается неизменным
- TTL IPNS: 24 часа
- Запись подписывается приватным ключом

### 2.5 Анонсы через PubSub

#### 2.5.1 Провайдер PubSub
- Всегда используется встроенная реализация libp2p PubSub
- Независимо от режима IPFS
- Причины:
  - IPFS Desktop убрал PubSub из HTTP API
  - Обеспечивает консистентность PubSub
- Встроенный PubSub:
  - Легковесный libp2p-узел
  - Только протокол PubSub
  - Отдельен от IPFS-хранилища
  - Использует стандартные bootstrap-пиры libp2p

#### 2.5.2 Формат сообщения
```json
{
  "version": 3,
  "ipns": "k51qzi5uqu5dh9ihj8p0dxgzm4jw8m8q9tqxm...",
  "publicKey": "CAASogEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC...",
  "collectionSize": 60,
  "timestamp": 1700000000,
  "signature": "base64_encoded_signature"
}
```

**Поля:**
- `version` (int): счётчик обновлений (увеличивается при изменениях)
- `ipns` (string): IPNS-хеш, указывающий на текущий индекс
- `publicKey` (string): публичный ключ в Base64 для верификации
- `collectionSize` (int): количество записей в NDJSON
- `timestamp` (int): Unix-время в секундах
- `signature` (string): подпись в Base64

#### 2.5.3 Подписывание сообщений
- Подпись создаётся над JSON-объектом без поля `signature`
- Алгоритм: Ed25519
- Подпись кодируется в Base64
- Получатели верифицируют подпись по `publicKey`

#### 2.5.4 Публикация в PubSub
- Топик: настраивается (`mdn/collections/announce` по умолчанию)
- Публикация через встроенный PubSub-узел
- Публикуется:
  - При первой полной загрузке файлов
  - После каждого обновления коллекции
  - Каждые час (независимо от изменений)
- При ошибке публикации:
  - Логировать ERROR
  - Ждать следующей попытки
  - Приложение продолжает работу

#### 2.5.5 Периодические анонсы
- Таймер: каждые 60 минут
- Публиковать текущее состояние коллекции
- `version` не увеличивается, если коллекция не менялась
- `timestamp` остаётся временем последнего реального обновления

### 2.6 Сохранение состояния

#### 2.6.1 Локальное состояние
Файл состояния: `~/.ipfs_publisher/state.json`

```json
{
  "version": 15,
  "ipns": "k51qzi5uqu5dh9ihj8p0dxgzm4jw8m8q9tqxm...",
  "lastIndexCID": "QmXyZ...",
  "files": {
    "/path/to/file1.mp3": {
      "cid": "QmAbc...",
      "mtime": 1700000000,
      "size": 5242880,
      "indexId": 1
    },
    "/path/to/file2.mkv": {
      "cid": "QmDef...",
      "mtime": 1700000100,
      "size": 104857600,
      "indexId": 2
    }
  }
}
```

#### 2.6.2 Восстановление после перезапуска
- При старте приложение загружает `state.json`
- Сканирует директории и определяет изменения:
  - Новые файлы (нет в state)
  - Изменённые файлы (mtime или size отличаются)
  - Удалённые файлы (есть в state, но отсутствуют на диске)
- Обрабатывать только изменённые элементы
- Обновлять state после обработки

#### 2.6.3 Обработка прерванных загрузок
- Если загрузка прервалась из-за падения приложения:
  - Файл может отсутствовать в state или иметь пустой CID
  - При перезапуске пометить файл для повторной обработки
- Проверять целостность индекса при старте

### 2.7 Обработка ошибок

#### 2.7.1 Внешний IPFS недоступен
- Ожидание с периодическими попытками (30с)
- Очередь файлов накапливается
- После восстановления обработать очередь

#### 2.7.2 Сбой старта встроенного узла
- При неудачном старте встроенного узла:
  - Логировать детальную ошибку (конфликт портов, повреждённый репозиторий и т.д.)
  - Для конфликтов портов: предложить изменить порты в конфиге
  - Для проблем с репозиторием: предложить очистку или миграцию
  - Завершить приложение с кодом ошибки

#### 2.7.3 Файл удалён во время обработки
- Обрабатывать ошибку "file not found" при чтении/загрузке
- Удалять файл из очереди
- Удалять запись из NDJSON, если она существовала
- Обновлять индекс и публиковать изменения

#### 2.7.4 Недостаточно места на диске
- Проверять свободное место перед обработкой больших файлов
- Для встроенного режима: мониторить размер репозитория
- Если места недостаточно:
  - Логировать ERROR
  - Пропускать файл
  - Продолжать с остальными файлами

#### 2.7.5 Некорректные права доступа
- Ловить "permission denied" ошибки
- Логировать проблемный файл
- Пропускать и продолжать

## 3. Конфигурация

### 3.1 Файл конфигурации
Формат: YAML
Путь по умолчанию: `./config.yaml` или `~/.ipfs_publisher/config.yaml`

```yaml
# Конфигурация IPFS
ipfs:
  # Режим: "external" или "embedded"
  mode: "external"  # по умолчанию
  
  # Настройки внешнего узла (mode: external)
  external:
    api_url: "http://localhost:5001"
    timeout: 300  # seconds
    add_options:
      nocopy: false  # работает только с filestore на внешнем узле
      pin: true
      chunker: "size-262144"
      raw_leaves: true
  
  # Настройки встроенного узла (mode: embedded)
  embedded:
    repo_path: "~/.ipfs_publisher/ipfs-repo"
    
    # Сетевые порты (должны отличаться от внешнего узла)
    swarm_port: 4002
    api_port: 5002
    gateway_port: 8081
    
    add_options:
      pin: true
      chunker: "size-262144"
      raw_leaves: true
    
    bootstrap_peers: []
    
    gc:
      enabled: true
      interval: 86400
      min_free_space: 1073741824

# PubSub (всегда встроенный)
pubsub:
  topic: "mdn/collections/announce"
  announce_interval: 3600
  bootstrap_peers: []
  listen_port: 0
  
# Директории для мониторинга
directories:
  - "/path/to/media1"
  - "/path/to/media2"
  - "/home/user/music"

# Обрабатываемые расширения
extensions:
  - "mp3"
  - "mp4"
  - "mkv"
  - "avi"
  - "flac"
  - "wav"

# Логирование
logging:
  level: "info"
  file: "~/.ipfs_publisher/logs/app.log"
  max_size: 100
  max_backups: 5
  console: true

# Поведение приложения
behavior:
  scan_interval: 10
  batch_size: 10
  progress_bar: true
  state_save_interval: 60
```

### 3.2 Аргументы командной строки
```bash
ipfs-publisher [flags]

Flags:
  -c, --config string     Path to config file (default "./config.yaml")
  -v, --version          Show version information
  -h, --help             Show help message
  --init                 Initialize configuration and generate keys
  --check-ipfs           Check IPFS connection and exit
  --dry-run              Scan and show what would be processed without uploading
  --ipfs-mode string     Override IPFS mode from config (external/embedded)
```

## 4. Техническая архитектура

### 4.1 Технологии
- Язык: Go 1.21+
- Интеграция IPFS:
  - external: `github.com/ipfs/go-ipfs-api`
  - embedded: `github.com/ipfs/kubo`
- PubSub: `github.com/libp2p/go-libp2p-pubsub`
- Мониторинг файлов: `github.com/fsnotify/fsnotify`
- Логирование: `github.com/sirupsen/logrus` или `go.uber.org/zap`
- Конфигурация: `github.com/spf13/viper`
- Прогресс-бар: `github.com/schollz/progressbar`
- Криптография: `crypto/ed25519`

### 4.2 Компоненты приложения

#### 4.2.1 Основные компоненты
1. FileWatcher — мониторинг файловой системы
2. IPFSClient — взаимодействие с IPFS (external/embedded)
3. EmbeddedIPFS — управление жизненным циклом встроенного узла
4. PubsubNode — встроенный libp2p PubSub (всегда)
5. IndexManager — управление NDJSON индексом
6. IPNSManager — создание и обновление IPNS
7. PubsubPublisher — публикация анонсов
8. StateManager — сохранение и восстановление состояния
9. KeyManager — генерация и хранение ключей

#### 4.2.2 Поток данных
```
FileWatcher → IPFSClient → IndexManager → IPNSManager
                ↓              ↓             ↓
         StateManager    PubsubNode ← PubsubPublisher
                              ↓
                      (Всегда встроен)
```

#### 4.2.3 Архитектура режимов IPFS
...

### 4.3 Модель конкурентности
- Основной goroutine: FileWatcher
- Отдельные goroutine: периодические PubSub объявления, встроенный узел
- Пул воркеров для параллельных загрузок (опционально)
- Каналы для координации
- Mutex для защиты общего состояния

### 4.4 Производительность

#### 4.4.1 Оптимизация для больших коллекций
- Инкрементальные обновления индекса
- Кэширование CID для неизменных файлов
- Batch processing
- Debounce 300ms

#### 4.4.2 Управление памятью
- Стриминг загрузки больших файлов (>100MB)
- Ограничение буфера при чтении индекса
- Мониторинг размера встроенного репозитория

#### 4.4.3 Особенности встроенного режима
- Очистка репозитория (GC)
- Ограничение хранения
- Мониторинг peer-соединений и DHT

## 5. Безопасность

### 5.1 Управление ключами
- Приватные ключи с правами `0600`
- Папка ключей `0700`
- Опциональное шифрование ключей (future)

### 5.2 Валидация входных данных
- Проверка путей директорий
- Ограничение максимального размера файлов
- Валидация расширений
- Санитизация имён файлов в индексе

### 5.3 Безопасность IPFS
- Опциональная аутентификация к HTTP API (external)
- Проверка TLS для HTTPS
- Rate limiting для защиты от DoS

### 5.4 Безопасность встроенного узла
- Изоляция сетевого пространства (опционально)
- Firewall для swarm-порта
- Фильтрация пиров (опционально)

## 6. Мониторинг и наблюдаемость

### 6.1 Уровни логирования
- DEBUG: подробности операций
- INFO: основные события
- WARN: потенциальные проблемы
- ERROR: ошибки

### 6.2 Метрики (опционально)
- Количество обработанных файлов
- Общий объём загруженных данных
- Время обработки
- Количество ошибок по типам
- Статистика встроенного узла (пиры, трафик)

### 6.3 Health checks
- Проверка доступности IPFS (по режиму)
- Проверка состояния встроенного узла
- Проверка PubSub соединения
- Проверка директорий
- Целостность state-файла

## 7. Стратегия тестирования

### 7.1 Unit tests
- Тесты для каждого компонента
- Моки для IPFS API
- Тесты подписи/верификации

### 7.2 Integration tests
- Тесты с внешним узлом
- Тесты со встроенным узлом
- Тесты PubSub доставки
- Тесты восстановления после сбоев

### 7.3 Performance tests
- Тесты на больших коллекциях (10k+)
- Тесты с большими файлами (>1GB)
- Нагрузочные тесты встроенного узла

## 8. Будущие улучшения

### 8.1 Потенциальные фичи
- Несколько IPNS ключей (по директории)
- Веб-UI для мониторинга
- Удалённые директории (SFTP, S3)
- Автоматическая очистка старых версий
- Метаданные файлов
- Поддержка плейлистов

### 8.2 Оптимизации
- Параллельные загрузки
- Дедупликация по хешам
- Сжатие индекс-файлов
- Инкрементальные IPNS обновления

## 9. Краевые случаи и ограничения

### 9.1 Известные ограничения
- Максимальный размер индекса: ~100MB
- Нет версии для удалённых файлов
- Нет ротации IPNS ключей
- Встроенный узел потребляет больше ресурсов

### 9.2 Краевые случаи
- Быстрые множественные изменения: debounce 300ms
- Циклические symlink: игнорируются
- Очень длинные имена: усечение до 255 символов
- Спецсимволы в именах: URL-encoding в индексе
- Дубликаты имён в разных директориях: добавить относительный путь
- Конфликты портов: приложение завершает работу с ошибкой
- Повреждение репозитория: предложить очистку

## 10. Критерии приёмки

### 10.1 Функциональные
- ✓ Корректная обработка добавления файлов
- ✓ Обновление CID при изменениях
- ✓ Удаление файлов из индекса
- ✓ Обновление IPNS при изменениях
- ✓ PubSub анонсы каждый час
- ✓ Восстановление состояния после перезапуска
- ✓ Оба режима IPFS работают
- ✓ PubSub работает в обоих режимах

### 10.2 Нефункциональные
- ✓ Обработка 1000 файлов < 5 минут (external с `--nocopy`)
- ✓ Память < 500MB для 10k файлов (external)
- ✓ Память < 1GB для 10k файлов (embedded)
- ✓ Восстановление после недоступности IPFS < 1 мин
- ✓ 99.9% uptime за 30 дней
- ✓ Встроенный узел стартует < 30s
- ✓ Конфликты портов детектируются заранее

## 11. Риски и mitigations

### 11.1 Критические риски
1. Race condition при быстрых изменениях
   - Решение: проверять mtime после загрузки

2. Потеря данных между обновлением индекса и state
   - Решение: при рестарте приложение ресканирует директории

3. Конфликты при запуске нескольких инстансов
   - Решение: lock-файл `~/.ipfs_publisher/.lock` с PID

4. Конфликты портов встроенного узла
   - Решение: проверка портов перед стартом

5. Повреждение репозитория встроенного узла
   - Решение: корректный shutdown, lock-файлы, процедуры восстановления

### 11.2 Масштабирование
1. Рост NDJSON индекса
   - Решение: мониторинг размера, разбиение или миграция в SQLite

2. Пиковое потребление памяти при загрузке индекса
   - Решение: стриминг и построчная обработка

3. Переполнение счётчика версий
   - Решение: использовать `uint64`

### 11.3 Надёжность
1. IPNS неуспевает за изменениями
   - Решение: периодический refresh IPNS каждые 12 часов

2. PubSub сообщения могут быть пропущены
   - Решение: часовые повторы

3. Нет проверки целостности загруженных данных
   - Решение: опциональная верификация через чтение из IPFS

### 11.4 UX
1. Нет индикатора прогресса при первом запуске
   - Решение: прогресс-бар с ETA

2. Неочевидность причин игнорирования файла
   - Решение: явные WARNING логи

3. Сложность встроенного режима
   - Решение: документация и индикатор режима в логах

### 11.5 Безопасность
1. Подделка публичного ключа в PubSub
   - Решение: whitelist доверенных ключей у получателей

2. Спам в PubSub
   - Решение: rate limiting у получателей

### 11.6 Операционные риски
1. Нет очистки старых CID
   - Решение: GC или unpin старых версий

2. Сложность отладки проблем с IPFS
   - Решение: подробные логи запросов/ответов

## 12. Рекомендации по устранению

### 12.1 Приоритет (MVP)
1. Lock-файл для предотвращения множественных запусков
2. Интегрит-check (mtime после загрузки)
3. `uint64` для счётчика версий
4. Graceful shutdown и сохранение state
5. Проверка доступности портов перед стартом встроенного узла
6. Отдельный PubSub узел с bootstrap

### 12.2 Средний приоритет (v1.1)
1. Стриминговая обработка индекса для больших коллекций
2. Мониторинг размера индекса с оповещениями
3. Retry с экспоненциальным бэкоффом для IPFS операций
4. Периодический refresh IPNS (12 часов)
5. GC встроенного узла
6. Мониторинг числа пиров PubSub

### 12.3 Низкий приоритет (future)
1. Опциональная верификация загруженных файлов
2. Chunked index для >100k файлов
3. Метрики и мониторинг
4. Автоматический GC старых CID
5. Веб UI
6. Гибридный режим IPFS

## 13. План реализации (фазы)

## Продолжение PRD — фазы реализации, примеры и деплой

### Фаза 1: Базовая структура и конфигурация (1-2 дня)
**Цель**: Настроить проект, конфигурацию и базовые компоненты

**Задачи:**
1. Инициализация Go-модуля и структуры проекта
2. Реализация загрузки YAML-конфига с поддержкой выбора режима IPFS
3. Настройка логирования (файл + консоль)
4. Реализация lock-файла
5. Базовая CLI-структура с флагами
6. Валидация конфигурации (проверка портов, путей)

**Структура проекта:**
```
ipfs-publisher/
├── cmd/
│   └── ipfs-publisher/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── logger/
│   │   └── logger.go
│   └── lockfile/
│       └── lockfile.go
├── config.yaml
└── go.mod
```

**Ручные тесты:**
```bash
# Запуск с конфигом
./ipfs-publisher --config ./config.yaml

# Проверка lock-файла
./ipfs-publisher  # первый экземпляр
./ipfs-publisher  # второй экземпляр должен завершиться с ошибкой

# Просмотр логов
cat ~/.ipfs_publisher/logs/app.log

# Валидация конфига
./ipfs-publisher --config invalid.yaml  # ожидается ошибка
```

**Критерии готовности:**
- ✓ Приложение стартует и читает конфиг
- ✓ Режим IPFS парсится корректно
- ✓ Логи пишутся в файл и в консоль
- ✓ Второй экземпляр не стартует
- ✓ Graceful shutdown по Ctrl+C

---

### Фаза 2: Внешний IPFS клиент и базовые операции (2-3 дня)
**Цель**: Подключиться к внешнему IPFS и реализовать загрузку файлов

**Задачи:**
1. Определить интерфейс `IPFSClient`
2. Реализовать external клиент (HTTP API)
3. Реализовать подключение и health-check
4. Реализовать добавление файла в IPFS
5. Обработка ошибок и retry
6. Поддержка `--nocopy` и `--pin`
7. IPNS-операции через внешний узел

**Новые файлы:**
```
internal/
├── ipfs/
│   ├── client.go        # интерфейс
│   ├── external.go      # реализация HTTP API
│   └── options.go
```

**Ручные тесты:**
```bash
# Запустить внешний ipfs daemon
ipfs daemon

./ipfs-publisher --check-ipfs --ipfs-mode external
./ipfs-publisher --test-upload /path/to/test.mp3
```

**Критерии готовности:**
- ✓ Подключение к внешнему IPFS
- ✓ Файлы загружаются и возвращают CID
- ✓ `--nocopy` и pinning работают

---

### Фаза 3: Встроенный IPFS-узел (3-4 дня)
**Цель**: Реализовать полноценный встроенный IPFS-узел

**Задачи:**
1. Реализовать wrapper для встроенного узла
2. Инициализация репозитория
3. Проверка доступности портов
4. Управление lifecycle (start/stop)
5. Конфигурирование портов
6. Bootstrap peers
7. Грейсфул shutdown
8. Реализация IPFSClient для embedded

**Новые файлы:**
```
internal/
├── ipfs/
│   ├── embedded.go
│   └── repo.go
```

**Ручные тесты:**
```bash
# Первый запуск в embedded режиме
rm -rf ~/.ipfs_publisher/ipfs-repo
./ipfs-publisher --ipfs-mode embedded

# Тест конфликтов портов
ipfs daemon &
./ipfs-publisher --ipfs-mode embedded
```

**Критерии готовности:**
- ✓ Репозиторий инициализируется
- ✓ Конфликты портов детектируются
- ✓ Узел стартует и принимает подключения
- ✓ Graceful shutdown

---

### Фаза 4: Встроенный PubSub (2-3 дня)
**Цель**: Реализовать отдельный libp2p PubSub-узел

**Задачи:**
1. Создать лёгкий libp2p-узел для PubSub
2. Включить GossipSub
3. Bootstrap peer discovery
4. Публикация сообщений
5. Интеграция с обоими режимами IPFS
6. Подпись и верификация сообщений

**Новые файлы:**
```
internal/
├── pubsub/
│   ├── node.go
│   ├── publisher.go
│   └── message.go
```

**Ручные тесты:**
```bash
./ipfs-publisher --ipfs-mode external
ipfs pubsub sub mdn/collections/announce
./ipfs-publisher --test-pubsub
```

**Критерии готовности:**
- ✓ PubSub узел стартует в обоих режимах
- ✓ Сообщения публикуются и подписываются

---

### Фаза 5: Сканирование директорий и создание индекса (2-3 дня)
**Цель**: Сканировать директории и формировать NDJSON индекс

**Задачи:**
1. Реализовать сканер директорий
2. Фильтрация по расширениям
3. Создание NDJSON индекса
4. Загрузка файлов в IPFS (mode-aware)
5. Загрузка индекса в IPFS
6. Прогресс-бар для больших батчей

**Новые файлы:**
```
internal/
├── scanner/
│   └── scanner.go
├── index/
│   ├── manager.go
│   └── ndjson.go
```

**Ручные тесты:**
```bash
./ipfs-publisher --dry-run --ipfs-mode external
./ipfs-publisher --ipfs-mode embedded
```

**Критерии готовности:**
- ✓ NDJSON индекс создаётся корректно
- ✓ Файлы загружаются локально и индекс загружается в IPFS

---

### Фаза 6: IPNS и управление ключами (2 дня)
**Цель**: Генерация ключей и публикация индекса через IPNS

**Задачи:**
1. Генерация Ed25519 ключевой пары
2. Сохранение ключей с правильными правами
3. Создание и обновление записи IPNS (mode-aware)
4. Интеграция со state management

**Новые файлы:**
```
internal/
├── keys/
│   └── manager.go
├── ipns/
│   └── manager.go
```

**Ручные тесты:**
```bash
rm -rf ~/.ipfs_publisher/keys
./ipfs-publisher
ls -la ~/.ipfs_publisher/keys
```

**Критерии готовности:**
- ✓ Ключи генерируются и имеют корректные права
- ✓ IPNS запись создаётся и разрешается

---

### Фаза 7: Полная интеграция PubSub (1-2 дня)
**Цель**: Интегрировать PubSub с обновлениями индекса

**Задачи:**
1. Подключение публикации при изменениях индекса
2. Периодические анонсы
3. Управление счётчиком версий
4. Подпись сообщений ключами IPNS
5. Обработка ошибок и retries

**Ручные тесты:**
```bash
ipfs pubsub sub mdn/collections/announce &
./ipfs-publisher
```

**Критерии готовности:**
- ✓ Анонсы публикуются при изменениях и по расписанию
- ✓ Подписи верифицируемы

---

### Фаза 8: Наблюдение за файлами и state management (2-3 дня)
**Цель**: Реальное время отслеживания изменений и сохранение состояния

**Задачи:**
1. Интеграция `fsnotify`
2. Обработка create/modify/delete/rename
3. Инкрементальное обновление индекса
4. Debounce для частых изменений
5. Сохранение и восстановление state

**Новые файлы:**
```
internal/
├── watcher/
│   └── watcher.go
├── state/
│   └── manager.go
```

**Ручные тесты:**
```bash
./ipfs-publisher
# Добавлять/изменять/удалять файлы и проверять логи/публикации
```

**Критерии готовности:**
- ✓ Реагирование на события файловой системы
- ✓ State сохраняется и восстанавливается

---

### Фаза 9: Финальная полировка и edge-cases (2-3 дня)
**Цель**: Обработать краевые случаи и довести UX

**Задачи:**
1. Улучшение ошибок и логов
2. Документация и справка
3. Обработка всех указанных краевых случаев
4. Performance tuning
5. Проверки на утечки памяти

**Ручные тесты:**
```bash
./ipfs-publisher --help
./ipfs-publisher --init
```

**Критерии готовности:**
- ✓ Документация и логирование улучшены
- ✓ Краевые случаи покрыты

---

### Фаза 10: Интеграционные тесты и готовность к проду (1-2 дня)
**Цель**: End-to-end тестирование и финальная валидация

**Задачи:**
1. Полный набор интеграционных тестов
2. Тесты всех комбинаций режимов
3. Долговременные тесты стабильности
4. Документация деплоя и триблшутинг
5. Подготовка релиз-артефактов

**Ручные тесты:**
```bash
# Полный workflow external и embedded
./ipfs-publisher --ipfs-mode external --init
./ipfs-publisher --ipfs-mode embedded --init
```

**Критерии готовности:**
- ✓ Интеграционные тесты проходят
- ✓ Долгоживущие тесты успешны
- ✓ Документация готова

---

## Дополнения: финальные чеклисты, примеры конфига и деплой

### Итоговый чеклист готовности к продакшену

- Функциональность: сканирование директорий, загрузка в IPFS, NDJSON, IPNS, PubSub, state
- IPFS интеграция: external и embedded, проверка портов, GC
- Надёжность: lock-файл, graceful shutdown, retry
- UX: прогресс-бар, понятные логи, CLI-флаги
- Безопасность: права ключей, подписи PubSub
- Производительность: требования по памяти и стриминг
- Документация: README, примеры, деплой-гайд

### Примеры конфигураций и деплой

(см. основной файл PRD — там приведены примеры External/Embedded/Production)

### Руководство по развёртыванию (кратко)

- Создать системного пользователя `ipfs-publisher`
- Копировать бинарник и конфиг в `/usr/local/bin` и `/etc/ipfs-publisher`
- Создать systemd unit, включить и запустить
- Проверить логи через `journalctl -u ipfs-publisher`