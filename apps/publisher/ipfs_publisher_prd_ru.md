# Техническое задание продукта: Публикатор медиаколлекций в IPFS

## 1. Обзор

### 1.1 Цель
Приложение на Go для автоматической публикации медиаколлекций в IPFS с объявлением через Pubsub. Приложение отслеживает сконфигурированные директории, загружает медиафайлы в IPFS, создаёт индексный файл с метаданными и публикует указатель на коллекцию через IPNS и Pubsub.

### 1.2 Целевая аудитория
- Пользователи, которые хотят распространять медиаколлекции через IPFS  
- Хосты децентрализованных медиабиблиотек  
- Провайдеры контента в P2P сетях

## 2. Функциональные требования

### 2.1 Мониторинг файловой системы

#### 2.1.1 Наблюдение за директориями
- Приложение отслеживает список директорий, указанных в конфигурации  
- Рекурсивное сканирование поддиректорий  
- Использовать системный наблюдатель за файловой системой (`fsnotify` библиотека для Go)  
- Отслеживать события:
  - Создание нового файла
  - Изменение существующего файла (время модификации)
  - Удаление файла
  - Переименование файла

#### 2.1.2 Фильтрация файлов
- Обрабатывать только файлы с расширениями из белого списка в конфиге  
- Сравнение расширений без учёта регистра  
- Игнорировать скрытые файлы (начинающиеся с `.`)  
- Игнорировать временные файлы и системные директории

#### 2.1.3 Обнаружение изменений
- При обнаружении изменения файла проверять по:
  - Времени модификации (mtime)
  - Размеру файла
- Сравнение хешей не используется в целях оптимизации производительности

### 2.2 Интеграция с IPFS

#### 2.2.1 Режимы работы IPFS-узла

Приложение поддерживает два режима работы IPFS-узла:

**Встроенный режим (по умолчанию):**
- Запуск полноценного IPFS-узла внутри приложения  
- Полная функциональность IPFS включая DHT, bitswap и маршрутизацию контента  
- PubSub использует тот же экземпляр libp2p, что и IPFS-узел  
- Ноль внешних зависимостей — полностью автономно  
- Рекомендуется для большинства пользователей и для продакшн-развёртываний

**Внешний режим:**
- Подключение к существующему IPFS-узлу (например, IPFS Desktop, kubo daemon)  
- Использование HTTP API для файловых операций (add, pin, get)  
- Отдельный облегчённый libp2p-узел для PubSub (потому что внешние IPFS-узлы не предоставляют PubSub через HTTP API)  
- Полезно для разработки или когда IPFS Desktop уже запущен

**Архитектура PubSub:**
- **Встроенный IPFS-режим**: PubSub запускается на том же экземпляре libp2p, что и IPFS  
  - Единый идентификатор peer
  - Единый swarm-порт
  - PubSub автоматически включается при инициализации IPFS-узла
- **Внешний IPFS-режим**: Отдельный облегчённый libp2p-узел только для PubSub  
  - Свой peer-идентификатор (отличный от внешнего IPFS-узла)  
  - Свой swarm-порт  
  - Использует те же bootstrap peers, что и IPFS для сетевой связности  
  - DHT включён для обнаружения пиров

**Выбор режима:**
- Жёстко задаётся в файле конфигурации  
- Пользователь явно выбирает режим  
- Нет автоматического перехода между режимами  
- Для смены режима требуется перезапуск приложения

#### 2.2.2 Подключение к внешнему IPFS
- Подключение к IPFS-узлу через HTTP API  
- Параметры подключения берутся из конфига (URL, порт)  
- Если узел недоступен:
  - Записать в лог ERROR
  - Пытаться переподключиться каждые 30 секунд
  - Приложение не завершает работу, ожидает доступности узла

#### 2.2.3 Встроенный IPFS-узел

**Инициализация:**
- При первом запуске инициализировать репозиторий IPFS в `~/.ipfs_publisher/ipfs-repo`  
- Сгенерировать идентификатор пира (ключевую пару)  
- Использовать стандартные bootstrap-узлы IPFS для подключения к DHT  
- Репозиторий сохраняется между запусками

**Конфигурация:**
- Пользовательские порты, чтобы избежать конфликтов с внешними узлами  
- Настраиваемые порты swarm, API и gateway  
- Порт по умолчанию отличны от стандартных IPFS (4001, 5001, 8080)

**Проверки при старте:**
- Перед запуском проверить доступность настроенных портов  
- Если какой-либо порт занят:
  - Записать ERROR: "Port {port} is already in use. Please check if another IPFS node is running or change ports in config."
  - Завершить приложение с ненулевым кодом возврата
  - Предложить проверить `ipfs id` или `lsof -i :{port}`

**Жизненный цикл:**
- Запуск встроенного узла при старте приложения  
- Корректное завершение при остановке приложения  
- Ожидание завершения ожидающих операций перед shutdown

**Функции:**
- Полные возможности IPFS-узла  
- Участие в DHT для маршрутизации контента  
- Bitswap для обмена контентом  
- Пиннинг и хранение контента  
- Сборка мусора (опционально, настраивается)

#### 2.2.4 Загрузка файлов в IPFS
- Загружать файлы последовательно (по одному)  
- Использовать активный IPFS-узел (внешний или встроенный)  
- Поддерживать опции `ipfs add`:
  - `--nocopy` (опционально, из конфига, только для внешнего режима с filestore)
  - `--pin` (опционально, из конфига)
  - `--chunker` (опционально, из конфига)
  - `--raw-leaves` (опционально, из конфига)
  - Другие опции через конфиг
- Получать CID для каждого загруженного файла  
- Логировать процесс:
  - INFO: начало загрузки файла
  - INFO: успешная загрузка с CID
  - ERROR: ошибка загрузки с деталями

#### 2.2.5 Отслеживание прогресса
- Показывать индикатор прогресса при обработке большого количества файлов (>10)  
- Информация в прогрессбаре:
  - Текущий обрабатываемый файл
  - Обработано/всего
  - Процент завершения
  - Индикатор текущего режима IPFS
- Подробные логи записываются в лог-файл параллельно с прогрессбаром

### 2.3 Управление индексом коллекции

#### 2.3.1 Формат NDJSON
```json
{"id":1,"CID":"Qmd7EioyCPrbGMTry4XSXL82jnBNcUSTN5hkiVv96Pipxx","filename":"song.mp3","extension":"mp3"}
{"id":2,"CID":"Qmd7EioyCPrbGMTry4XSXL82jnBNcsdfasdfadfasdfasd","filename":"video.mkv","extension":"mkv"}
```

**Поля:**
- `id` (int): Последовательный номер записи (начинается с 1)  
- `CID` (string): IPFS CID загруженного файла  
- `filename` (string): Оригинальное имя файла  
- `extension` (string): Расширение файла (без точки)

#### 2.3.2 Создание и обновление индекса
- При первом запуске создать пустой NDJSON-файл  
- При добавлении нового файла:
  - Добавить новую запись в NDJSON
  - Присвоить `id` следующий последовательный номер
- При изменении существующего файла:
  - Найти запись по `filename`
  - Обновить только поле `CID`
  - `id` остаётся без изменений
- При удалении файла:
  - Удалить соответствующую строку из NDJSON
  - `id` других записей НЕ меняются (допускаются разрывы в нумерации)
- При переименовании файла:
  - Обновить поле `filename` в существующей записи
  - Сохранить `id` и `CID`

#### 2.3.3 Загрузка индекса в IPFS
- После обновления NDJSON загрузить индексный файл в IPFS  
- Использовать активный IPFS-узел (внешний или встроенный)  
- Получить CID для индексного файла  
- Зафиксировать (pin) индексный файл (если включено в конфиге)

### 2.4 Управление IPNS

#### 2.4.1 Генерация ключей
- При первом запуске сгенерировать ключевую пару Ed25519  
- Ключи хранятся локально в:
  - `~/.ipfs_publisher/keys/private.key`
  - `~/.ipfs_publisher/keys/public.key`
- При последующих запусках используются существующие ключи  
- Один IPNS-ключ на всё приложение (для всех директорий)

#### 2.4.2 Создание и обновление IPNS
- При первой публикации создать IPNS-запись  
- IPNS-запись указывает на текущий CID индексного файла  
- Для IPNS-операций использовать активный IPFS-узел (внешний или встроенный)  
- При обновлениях индекса:
  - Обновить IPNS-запись до нового CID
  - IPNS-хэш остаётся тем же
- TTL IPNS-записи: 24 часа  
- IPNS-запись подписывается приватным ключом

### 2.5 Анонс через Pubsub

#### 2.5.1 Архитектура PubSub

**Встроенный IPFS-режим:**
- PubSub работает на том же экземпляре libp2p/IPFS узла  
- Отдельный PubSub-узел не требуется  
- Используется идентичность peer и swarm-порт IPFS-узла  
- PubSub протокол автоматически включается при инициализации IPFS-узла  
- Участвует в DHT IPFS для обнаружения пиров

**Внешний IPFS-режим:**
- Отдельный облегчённый libp2p-узел только для PubSub  
- Причина: внешние IPFS-узлы (IPFS Desktop, kubo) убрали PubSub-эндпоинт из HTTP API  
- Собственная идентичность пира (независимая от внешнего IPFS-узла)  
- Собственный swarm-порт (настраиваемый)  
- Использует те же bootstrap peers, что и IPFS, для сетевой связности  
- DHT включён для объявления и обнаружения пиров, подписанных на топики  
- Минимальное потребление ресурсов (только PubSub и DHT протоколы)

#### 2.5.2 Формат сообщения
```json
{
  "version": 3,
  "ipns": "k51qzi5uqu5dh9ihj8p0dxgzm4jw8m8q9tqxm...",
  "publicKey": "CAASogEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC...",
  "collectionSize": 60,
  "timestamp": 1700000000,
  "signature": "base64_encoded_signature"
}
```

**Поля:**
- `version` (int): Счётчик обновлений (увеличивается при каждом изменении коллекции)  
- `ipns` (string): IPNS-хэш, указывающий на текущую версию индекса  
- `publicKey` (string): Публичный ключ в base64 для верификации  
- `collectionSize` (int): Количество записей в NDJSON-файле  
- `timestamp` (int): Unix-временная метка в секундах  
- `signature` (string): Подпись сообщения в base64

#### 2.5.3 Подпись сообщений
- Подпись создаётся над JSON-объектом без поля `signature`  
- Алгоритм: Ed25519  
- Подпись кодируется в Base64  
- Получатели могут проверить подпись, используя `publicKey`

#### 2.5.4 Публикация в Pubsub
- Топик: настраивается в конфиге (по умолчанию `mdn/collections/announce`)  
- Публикация через:
  - **Встроенный режим**: экземпляр libp2p IPFS-узла  
  - **Внешний режим**: отдельный libp2p PubSub-узел  
- Публикация происходит:
  - При первой загрузке всех файлов
  - После каждого обновления коллекции
  - Каждые час (независимо от изменений)
- При ошибке публикации:
  - Записать ERROR
  - Ожидать следующей попытки (через час или при следующем изменении)
  - Приложение продолжает работу

#### 2.5.5 Периодические анонсы
- Таймер: каждые 60 минут  
- Публикуется текущее состояние коллекции  
- `version` не увеличивается, если коллекция не изменилась  
- `timestamp` остаётся временем последнего реального обновления коллекции

### 2.6 Сохранение состояния

#### 2.6.1 Локальное состояние
Файл состояния: `~/.ipfs_publisher/state.json`

```json
{
  "version": 15,
  "ipns": "k51qzi5uqu5dh9ihj8p0dxgzm4jw8m8q9tqxm...",
  "lastIndexCID": "QmXyZ...",
  "files": {
    "/path/to/file1.mp3": {
      "cid": "QmAbc...",
      "mtime": 1700000000,
      "size": 5242880,
      "indexId": 1
    },
    "/path/to/file2.mkv": {
      "cid": "QmDef...",
      "mtime": 1700000100,
      "size": 104857600,
      "indexId": 2
    }
  }
}
```

#### 2.6.2 Восстановление после перезапуска
- При старте приложение загружает `state.json`  
- Сканирует сконфигурированные директории чтобы определить изменения:
  - Новые файлы (отсутствуют в состоянии)
  - Изменённые файлы (mtime или размер отличаются)
  - Удалённые файлы (есть в состоянии, но отсутствуют на диске)
- Обрабатывать только изменённые файлы  
- Обновлять состояние после обработки

#### 2.6.3 Обработка прерванных загрузок
- Если загрузка файла была прервана из-за краша приложения:
  - Файл может отсутствовать в состоянии или иметь пустой CID
  - При рестарте файл помечается для повторной обработки
- Проверять целостность индекса при старте

### 2.7 Обработка ошибок

#### 2.7.1 IPFS недоступен (внешний режим)
- Ожидать с периодическими попытками переподключения (30с)  
- Очередь обработки файлов накапливается  
- Обрабатывать очередь после восстановления соединения

#### 2.7.2 Сбой запуска встроенного IPFS
- Если встроенный узел не запускается:
  - Записать детальную ошибку (конфликт портов, повреждение репозитория и т.д.)
  - Для конфликтов портов: предложить перенастройку портов
  - Для проблем с репозиторием: предложить очистку или миграцию репозитория
  - Завершить приложение с кодом ошибки

#### 2.7.3 Файл удалён во время обработки
- Обрабатывать ошибки "file not found" при чтении/загрузке
- Удалить файл из очереди обработки
- Удалить запись из NDJSON, если она существовала
- Обновить индекс и опубликовать изменения

#### 2.7.4 Недостаточно места на диске
- Проверять доступное место перед обработкой больших файлов
- Для встроенного режима: мониторить размер репозитория
- Если места недостаточно:
  - Записать ERROR с предупреждением
  - Пропустить файл
  - Продолжить обработку других файлов

#### 2.7.5 Некорректные права доступа
- Обрабатывать ошибки "permission denied"
- Логировать с указанием проблемного файла
- Пропустить файл и продолжить

## 3. Конфигурация

### 3.1 Файл конфигурации
Формат: YAML  
Путь по умолчанию: `./config.yaml` или `~/.ipfs_publisher/config.yaml`

```yaml
# Конфигурация IPFS-узла
ipfs:
  # Режим: "embedded" (запуск IPFS внутри приложения) или "external" (использовать существующий IPFS-узел)
  mode: "embedded"  # по умолчанию
  
  # Настройки внешнего узла (используются когда mode: external)
  external:
    api_url: "http://localhost:5001"
    timeout: 300  # секунд
    add_options:
      nocopy: false  # работает только с filestore, включённым на внешнем узле
      pin: true
      chunker: "size-262144"
      raw_leaves: true
  
  # Настройки встроенного узла (используются когда mode: embedded)
  embedded:
    repo_path: "~/.ipfs_publisher/ipfs-repo"
    
    # Сетевые порты (должны отличаться от внешнего IPFS-узла, если оба работают)
    swarm_port: 4002      # libp2p swarm (по умолчанию IPFS: 4001)
    api_port: 5002        # HTTP API (по умолчанию IPFS: 5001)
    gateway_port: 8081    # HTTP-шлюз (по умолчанию IPFS: 8080)
    
    # Настройки хранения
    add_options:
      pin: true
      chunker: "size-262144"
      raw_leaves: true
    
    # Bootstrap-пиры (оставить пустым для использования стандартных bootstrap-узлов IPFS)
    bootstrap_peers: []
    
    # Сборка мусора
    gc:
      enabled: true
      interval: 86400  # секунд (24 часа)
      min_free_space: 1073741824  # байт (1GB)

# Конфигурация PubSub
pubsub:
  topic: "mdn/collections/announce"
  announce_interval: 3600  # секунд (1 час)
  
  # Настройки отдельного PubSub-узла (используется только в внешнем режиме IPFS)
  # В встроенном режиме PubSub использует тот же экземпляр libp2p, что и IPFS
  standalone:
    bootstrap_peers: []  # оставить пустым для стандартных bootstrap-узлов IPFS
    swarm_port: 4003     # libp2p swarm порт для отдельного PubSub-узла
    enable_dht: true     # DHT для обнаружения пиров и объявления топиков

# Директории для мониторинга
directories:
  - "/path/to/media1"
  - "/path/to/media2"
  - "/home/user/music"

# Расширения файлов для обработки (без учёта регистра)
extensions:
  - "mp3"
  - "mp4"
  - "mkv"
  - "avi"
  - "flac"
  - "wav"

# Логирование
logging:
  level: "info"  # debug, info, warn, error
  file: "~/.ipfs_publisher/logs/app.log"
  max_size: 100  # MB
  max_backups: 5
  console: true

# Поведение приложения
behavior:
  scan_interval: 10  # секунд, как часто проверять изменения
  batch_size: 10  # файлов обрабатывать за один батч
  progress_bar: true
  state_save_interval: 60  # секунд
```

### 3.2 Аргументы командной строки
```bash
ipfs-publisher [flags]

Flags:
  -c, --config string     Path to config file (default "./config.yaml")
  -v, --version          Show version information
  -h, --help             Show help message
  --init                 Initialize configuration and generate keys
  --check-ipfs           Check IPFS connection and exit
  --dry-run              Scan and show what would be processed without uploading
  --ipfs-mode string     Override IPFS mode from config (external/embedded)
```

## 4. Техническая архитектура

### 4.1 Технологический стек
- **Язык**: Go 1.21+  
- **Интеграция с IPFS**: 
  - Внешний режим: `github.com/ipfs/go-ipfs-api` (HTTP API клиент)
  - Встроенный режим: `github.com/ipfs/kubo` (полноценный IPFS-узел)
- **PubSub**: `github.com/libp2p/go-libp2p-pubsub` (встроен в IPFS или standalone)
- **Мониторинг ФС**: `github.com/fsnotify/fsnotify`
- **Логирование**: `github.com/sirupsen/logrus` или `go.uber.org/zap`
- **Конфигурация**: `github.com/spf13/viper`
- **Прогресс-бар**: `github.com/schollz/progressbar`
- **Криптография**: `crypto/ed25519` (стандартная библиотека)

### 4.2 Компоненты приложения

#### 4.2.1 Основные компоненты
1. **FileWatcher**: Мониторинг ФС  
2. **IPFSClient**: Взаимодействие с IPFS (внешний или встроенный)  
3. **EmbeddedIPFS**: Управление жизненным циклом встроенного IPFS-узла  
4. **StandalonePubSub**: Отдельный libp2p PubSub-узел (только для внешнего режима IPFS)  
5. **IndexManager**: Управление NDJSON-индексом  
6. **IPNSManager**: Создание и обновление IPNS-записей  
7. **PubsubPublisher**: Публикация анонсов в Pubsub (учёт режима)
8. **StateManager**: Сохранение и восстановление состояния
9. **KeyManager**: Генерация и управление ключами

#### 4.2.2 Поток данных
```
FileWatcher → IPFSClient → IndexManager → IPNSManager
                ↓              ↓             ↓
         StateManager    PubsubPublisher (mode-aware)
                              ↓
                    ┌─────────┴─────────┐
                    │                   │
            Embedded IPFS         Standalone PubSub
            (with PubSub)         (external mode only)
```

#### 4.2.3 Архитектура по режимам IPFS

**Внешний режим:**
```
Application
├── HTTP API Client → External IPFS Node
│   ├── Add files
│   ├── Pin content
│   └── IPNS publish
└── Standalone PubSub Node (libp2p)
    ├── Own peer identity
    ├── Own swarm port (4003)
    ├── DHT for peer discovery
    ├── Same bootstrap as IPFS
    └── Announce messages
```

**Встроенный режим:**
```
Application
└── Embedded IPFS Node (full libp2p instance)
    ├── Add files
    ├── Pin content
    ├── IPNS publish
    ├── DHT routing
    ├── Bitswap
    └── PubSub (on same libp2p instance)
        └── Announce messages
```

### 4.3 Модель конкурентности
- Главная goroutine для FileWatcher  
- Отдельная goroutine для периодических анонсов Pubsub  
- Отдельная goroutine для встроенного IPFS-узла (если используется встроенный режим)  
- Отдельная goroutine для standalone PubSub-узла (если используется внешний режим)  
- Пул воркеров (опционально) для параллельных загрузок в IPFS  
- Каналы для координации между компонентами  
- Мьютекс для защиты разделяемого состояния

### 4.4 Соображения по производительности

#### 4.4.1 Оптимизация для больших коллекций
- Инкрементные обновления индекса (без полного пересканирования)  
- Кэширование CID для неизменных файлов  
- Пакетная обработка для множества изменений  
- Дебаунсинг для частых изменений (300ms)

#### 4.4.2 Управление памятью
- Потоковая загрузка для больших файлов (>100MB)  
- Ограничение размера буфера при чтении индекса  
- Периодическая очистка кэша состояния  
- Мониторинг размера встроенного IPFS-репозитория

#### 4.4.3 Особенности встроенного режима
- Очистка репозитория с помощью garbage collection  
- Настраиваемые лимиты хранения  
- Мониторинг подключений пиов и производительности DHT

## 5. Соображения по безопасности

### 5.1 Управление ключами
- Приватные ключи хранятся с правами `0600`  
- Права директории с ключами `0700`  
- Опциональное шифрование ключей паролем (будущее улучшение)

### 5.2 Валидация входных данных
- Валидация путей директорий (защита от traversal)
- Проверка максимального размера файла
- Валидация расширений файлов
- Санитизация имён файлов в индексе

### 5.3 Безопасность IPFS
- Опциональная аутентификация к IPFS API (внешний режим)
- Проверять TLS-сертификаты при использовании HTTPS
- Ограничение по частоте запросов для защиты от DoS

### 5.4 Безопасность встроенного узла
- Изолированное сетевое пространство имён (опционально)
- Правила firewall для swarm-порта
- Фильтрация пиров (опционально)

## 6. Мониторинг и наблюдаемость

### 6.1 Уровни логирования
- **DEBUG**: Подробная информация о каждой операции  
- **INFO**: Ключевые события (файл обработан, индекс обновлён, узел запущен)  
- **WARN**: Потенциальные проблемы (замедление обработки, конфликты портов)  
- **ERROR**: Ошибки, которые не прекращают работу приложения

### 6.2 Метрики (опционально)
- Количество обработанных файлов  
- Общий объём загруженных данных  
- Время обработки файлов  
- Количество ошибок по типам  
- Доступность IPFS-узла  
- Статистика встроенного узла (пиры, пропускная способность)  
- Скорость доставки сообщений PubSub

### 6.3 Проверки здоровья
- Проверять подключение к IPFS (учитывая режим)  
- Проверять здоровье встроенного узла (если применимо)  
- Проверять подключение PubSub-узла  
- Проверять доступность директорий  
- Проверять целостность файла состояния  
- Опциональный статус-эндпоинт

## 7. Стратегия тестирования

### 7.1 Unit-тесты
- Тесты для каждого компонента в изоляции  
- Мок IPFS API для тестирования IPFSClient  
- Тесты для корректной подписи/верификации
- Тесты жизненного цикла встроенного узла

### 7.2 Интеграционные тесты
- Тесты с внешним IPFS-узлом
- Тесты со встроенным IPFS-узлом
- Тесты доставки сообщений PubSub
- Тесты сценариев изменения файлов
- Тесты восстановления после ошибок
- Тесты переключения режимов

### 7.3 Тесты производительности
- Тесты с большими коллекциями (10000+ файлов)
- Тесты с большими файлами (>1GB)
- Тесты на утечки памяти для длительной работы
- Тесты использования ресурсов встроенным узлом

## 8. Будущие улучшения

### 8.1 Потенциальные функции
- Поддержка нескольких IPNS-ключей (на директорию)
- Веб-интерфейс для мониторинга
- Удалённые директории (SFTP, S3)
- Автоматическая очистка старых версий в IPFS
- Метаданные файлов (теги, описания)
- Поддержка плейлистов и альбомов
- Гибридный режим (внешнее хранение, встроенный PubSub)

### 8.2 Возможности для оптимизации
- Параллельные загрузки файлов в IPFS
- Дедупликация по хешу контента
- Сжатие индексного файла
- Инкрементные обновления IPNS
- Продвинутые стратегии маршрутизации пиров

## 9. Граничные случаи и ограничения

### 9.1 Известные ограничения
- Максимальный размер индексного файла: ~100MB (ограничения размеров блоков IPFS)  
- Версионирование удалённых файлов не поддерживается  
- Нет автоматической ротации IPNS-ключей  
- Нет встроенной репликации на другие IPFS-узлы  
- Встроенный узел требует больше ресурсов, чем внешний режим

### 9.2 Граничные случаи
- **Быстрые множественные изменения**: Дебаунс 300ms  
- **Циклические символические ссылки**: Игнорируются при сканировании  
- **Очень длинные имена файлов**: Обрезать до 255 символов  
- **Специальные символы в именах файлов**: URL-encode в индексе  
- **Дубликаты имён в разных директориях**: Добавлять относительный путь в `filename`
- **Конфликты портов**: Приложение завершает работу с ошибкой
- **Повреждение репозитория**: Предлагать очистку репозитория в сообщении об ошибке

## 10. Критерии приёмки

### 10.1 Функциональные
- ✓ Приложение корректно обрабатывает добавление новых файлов  
- ✓ Изменение файла обновляет его CID в индексе  
- ✓ Удаление файла удаляет его из индекса  
- ✓ IPNS обновляется корректно при изменениях  
- ✓ Pubsub-сообщения публикуются каждый час  
- ✓ Приложение восстанавливает состояние после перезапуска  
- ✓ Оба режима IPFS (внешний и встроенный) работают  
- ✓ PubSub работает в обоих режимах IPFS

### 10.2 Нефункциональные
- ✓ Обработка 1000 файлов занимает < 5 минут (с `--nocopy` во внешнем режиме)  
- ✓ Использование памяти < 500MB при 10000 файлах (внешний режим)  
- ✓ Использование памяти < 1GB при 10000 файлах (встроенный режим)  
- ✓ Приложение восстанавливается после недоступности IPFS < 1 минуты  
- ✓ 99.9% uptime при непрерывной 30-дневной работе  
- ✓ Встроенный узел стартует в течение 30 секунд  
- ✓ Конфликт портов обнаруживается и сообщается до старта узла

## 11. Риски и меры смягчения

### 11.1 Критические риски
1. **Гонки при быстрых изменениях файлов**
   - Проблема: файл может измениться во время загрузки в IPFS  
   - Смягчение: проверять mtime после загрузки, при несовпадении — перепроцессить

2. **Потеря данных между обновлением индекса и записью состояния**
   - Проблема: состояние не записано атомарно с операциями IPFS  
   - Смягчение: не критично для MVP. При рестарте приложение пересканирует директории и согласует различия

3. **Конфликты при параллельном запуске нескольких экземпляров**
   - Проблема: два экземпляра могут обрабатывать одни и те же файлы  
   - Смягчение: lock-файл (`~/.ipfs_publisher/.lock`) с проверкой PID, чтобы предотвратить множественные запуски

4. **Конфликты портов для встроенного узла**
   - Проблема: невозможно запустить, если порты заняты  
   - Смягчение: проверка доступности портов до запуска с понятными сообщениями об ошибке

5. **Повреждение репозитория встроенного узла**
   - Проблема: краши или некорректное завершение могут повредить репозиторий  
   - Смягчение: корректные обработчики завершения, lock-файлы репозитория, процедуры восстановления

### 11.2 Проблемы масштабирования
1. **NDJSON индекс растёт без контроля**
   - Проблема: при десятках тысяч файлов индекс становится огромным (>100MB)  
   - Риск: ограничение размера блока IPFS, медленная загрузка/обработка индекса  
   - Смягчение: мониторинг размера индекса. При превышении порога (например, 50MB) — рассмотреть разделение индексов или переход на другой формат (например, SQLite в IPFS)

2. **Всплески памяти при загрузке большого индекса**
   - Проблема: загрузка всего NDJSON в память для обновлений  
   - Смягчение: потоковый парсинг и построчное обновление индекса

3. **Переполнение счётчика версий**
   - Проблема: при большом количестве обновлений int может переполниться  
   - Смягчение: использовать `uint64` (достаточно для ~1.8e19 обновлений)

4. **Рост хранения встроенного узла**
   - Проблема: репозиторий растёт бесконечно  
   - Смягчение: настраиваемая сборка мусора, лимиты хранения

### 11.3 Проблемы надёжности
1. **IPNS-републикация может не успевать за изменениями**
   - Проблема: TTL IPNS 24 часа может приводить к устареванию  
   - Смягчение: периодическое обновление IPNS (каждые 12 часов) даже без изменений

2. **Pubsub-сообщения не гарантированно доставляются**
   - Проблема: получатели могут пропустить анонсы  
   - Смягчение: почасовые повторения уменьшают вероятность пропусков

3. **Нет проверки успешной персистенции в IPFS**
   - Проблема: API IPFS возвращает CID, но данные могут быть повреждены или неполны  
   - Смягчение: доверять IPFS API. Опционально добавить проверку, перечитывая файл из IPFS (в будущем)

4. **Изоляция standalone PubSub-узла**
   - Проблема: отдельный PubSub-узел (во внешнем режиме) может иметь проблемы с обнаружением пиров  
   - Смягчение: использовать стандартные bootstrap peers, включить DHT, мониторить количество пиров

### 11.4 UX-проблемы
1. **Отсутствие индикации прогресса при первом запуске**
   - Проблема: пользователь не видит прогресс
   - Смягчение: детализированный прогресс-бар с ETA

2. **Неясно, почему файл не обрабатывается**
   - Проблема: файл может игнорироваться по многим причинам (расширение, права)
   - Смягчение: явные WARNING-логи для проигнорированных файлов

3. **Сложность понимания встроенного режима**
   - Проблема: пользователи могут не понимать разницу между режимами
   - Смягчение: чёткая документация, разумные значения по умолчанию, индикатор режима в логах

### 11.5 Вопросы безопасности
1. **Публичный ключ в Pubsub может быть поддельным**
   - Проблема: злоумышленник может опубликовать другой `publicKey`
   - Смягчение: получатели должны поддерживать whitelist доверенных ключей

2. **Нет защиты от спама в Pubsub**
   - Проблема: злоумышленник может зафлудить топик
   - Смягчение: ограничение частоты на стороне получателей

3. **Сетевое воздействие встроенного узла**
   - Проблема: swarm-порт открыт в интернет
   - Смягчение: руководство по настройке firewall, опция приватных сетей

### 11.6 Операционные риски
1. **Нет автоматической очистки старых CID в IPFS**
   - Проблема: IPFS-узел может исчерпать пространство при частых обновлениях
   - Смягчение: периодическая GC или отписка старых версий (особенно для встроенного режима)

2. **Сложности отладки проблем с IPFS**
   - Проблема: ошибки API IPFS могут быть неинформативны
   - Смягчение: подробное логирование запросов/ответов IPFS, отладочные логи встроенного узла

3. **Сложность управления портами**
   - Проблема: пользователи могут не знать, какие порты настроить
   - Смягчение: разумные значения по умолчанию, понятные сообщения об ошибках, документация

## 12. Рекомендации по устранению проблем

### 12.1 Приоритетное (MVP)
1. Добавить lock-файл чтобы предотвратить множественные запуски
2. Реализовать проверку целостности (mtime после загрузки)
3. Использовать `uint64` для счётчика версий
4. Реализовать корректное завершение с сохранением состояния
5. Проверка доступности портов перед запуском встроенного узла
6. Отдельный PubSub-узел с корректным bootstrap

### 12.2 Средний приоритет (v1.1)
1. Реализовать потоковую обработку индекса для больших коллекций
2. Добавить мониторинг размера индекса с оповещениями
3. Добавить логику повторных попыток с экспоненциальным бэкоффом для операций IPFS
4. Реализовать периодическое обновление IPNS (каждые 12 часов)
5. Сборка мусора встроенного узла
6. Мониторинг числа пиров PubSub (по режиму)
7. Оптимизация потребления ресурсов standalone PubSub-узла

### 12.3 Низкий приоритет (в будущем)
1. Опциональная верификация загруженных файлов (флаг в конфиге)
2. Разбиение индексов для коллекций >100k файлов
3. Добавить метрики и мониторинг
4. Реализовать автоматическую очистку старых CID
5. Добавить веб-интерфейс для мониторинга
6. Поддержка гибридного режима IPFS

## 13. План реализации (по фазам)

### Фаза 1: Базовая структура и конфигурация (1-2 дня)
**Цель**: Настроить проект, конфигурацию и базовые компоненты

**Задачи:**
1. Инициализировать Go-модуль и структуру проекта
2. Реализовать загрузку YAML-конфигурации с выбором режима IPFS
3. Настроить логирование (файл + консоль)
4. Реализовать механизм lock-файла
5. Базовый CLI-скелет с флагами
6. Валидация конфигурации (конфликты портов, проверки путей)

**Структура проекта:**
```
ipfs-publisher/
├── cmd/
│   └── ipfs-publisher/
│       └── main.go
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── logger/
│   │   └── logger.go
│   └── lockfile/
│       └── lockfile.go
├── config.yaml
└── go.mod
```

**Ручные тесты:**
```bash
# Test 1: Run with config
./ipfs-publisher --config ./config.yaml

# Test 2: Lock file check
./ipfs-publisher  # first instance
./ipfs-publisher  # second instance should exit with an error

# Test 3: Logging
cat ~/.ipfs_publisher/logs/app.log

# Test 4: Config validation
./ipfs-publisher --config invalid.yaml  # should error

# Test 5: IPFS mode validation
# Set invalid mode in config, expect error
```

**Критерии готовности:**
- ✓ Приложение стартует и читает конфиг  
- ✓ Конфигурация режима IPFS парсится корректно  
- ✓ Логи пишутся в файл и в консоль  
- ✓ Второй экземпляр не может запуститься  
- ✓ Корректное завершение при Ctrl+C

---

### Фаза 2: Внешний IPFS-клиент и базовые операции (2-3 дня)
**Цель**: Подключиться к внешнему IPFS и реализовать загрузку файлов

**Задачи:**
1. Реализовать интерфейс `IPFSClient`
2. Реализовать внешний IPFS-клиент (HTTP API)
3. Реализовать подключение к внешнему IPFS API
4. Реализовать функцию добавления файла в IPFS
5. Обработка ошибок и логика повторных попыток
6. Поддержка опций `--nocopy` и `--pin`
7. Операции IPNS через внешний узел

**Новые файлы:**
```
internal/
├── ipfs/
│   ├── client.go        # Interface
│   ├── external.go      # HTTP API implementation
│   └── options.go
```

**Ручные тесты:**
```bash
# Prepare: start external IPFS daemon
ipfs daemon

# Test 1: Check connection
./ipfs-publisher --check-ipfs --ipfs-mode external
# Expect: "✓ Connected to IPFS node at http://localhost:5001"

# Test 2: Upload a single file (test command)
./ipfs-publisher --test-upload /path/to/test.mp3
# Expect: "Uploaded: test.mp3 -> QmXxx..."

# Test 3: --nocopy mode
./ipfs-publisher --test-upload /path/to/test.mp3 --nocopy
# Expect: successful upload with nocopy flag

# Test 4: IPFS unavailable handling
# Stop ipfs daemon
./ipfs-publisher --check-ipfs
# Expect: retries every 30s

# Test 5: Pinning
./ipfs-publisher --test-upload /path/to/test.mp3
ipfs pin ls | grep QmXxx
# Expect: file is pinned

# Test 6: IPNS operations
./ipfs-publisher --test-ipns
# Expect: IPNS record created and resolvable
```

**Критерии готовности:**
- ✓ Успешное подключение к внешнему IPFS API  
- ✓ Файлы загружаются и возвращают CIDs  
- ✓ Режим `--nocopy` работает  
- ✓ Пиннинг работает  
- ✓ Приложение ждёт IPFS при недоступности  
- ✓ Публикация/разрешение IPNS работает

---

### Фаза 3: Встроенный IPFS-узел (3-4 дня)
**Цель**: Реализовать полноценный встроенный IPFS-узел

**Задачи:**
1. Реализовать оболочку для встроенного IPFS-узла
2. Инициализация и управление репозиторием
3. Проверка доступности портов
4. Управление жизненным циклом узла (start/stop)
5. Настройка swarm/API/gateway портов
6. Подключение bootstrap-пиров
7. Корректное завершение и очистка
8. Реализовать тот же интерфейс IPFSClient для встроенного узла

**Новые файлы:**
```
internal/
├── ipfs/
│   ├── embedded.go      # Embedded node implementation
│   └── repo.go          # Repository management
```

**Ручные тесты:**
```bash
# Test 1: First run with embedded mode
rm -rf ~/.ipfs_publisher/ipfs-repo
./ipfs-publisher --ipfs-mode embedded
# Expect: 
# - Repository initialization
# - Node startup logs
# - Peer connections established

# Test 2: Port conflict detection
# Start external IPFS on default ports
ipfs daemon &
# Try to start with conflicting ports in config
./ipfs-publisher --ipfs-mode embedded
# Expect: Error message about port 4002/5002/8081 being occupied

# Test 3: Custom ports
# Update config with custom ports
./ipfs-publisher --ipfs-mode embedded
netstat -tuln | grep <custom_port>
# Expect: ports listening

# Test 4: Bootstrap and peer discovery
./ipfs-publisher --ipfs-mode embedded
# Wait 60 seconds
# Check logs for peer connections
# Expect: "Connected to X peers"

# Test 5: Repository persistence
./ipfs-publisher --ipfs-mode embedded
# Upload some files
# Stop and restart
./ipfs-publisher --ipfs-mode embedded
# Expect: Repository reused, peer identity preserved

# Test 6: Graceful shutdown
./ipfs-publisher --ipfs-mode embedded
# Send SIGTERM or Ctrl+C
# Expect: "Shutting down embedded IPFS node..." then clean exit

# Test 7: Upload via embedded node
./ipfs-publisher --ipfs-mode embedded --test-upload /path/to/test.mp3
# Expect: File added successfully
# Verify from external node:
ipfs cat <CID>
```

**Критерии готовности:**
- ✓ Встроенный узел инициализирует репозиторий  
- ✓ Конфликты портов обнаруживаются до старта  
- ✓ Узел запускается и принимает подключения  
- ✓ Bootstrap-пиры подключаются  
- ✓ Файлы можно добавлять через встроенный узел  
- ✓ Репозиторий сохраняется между запусками  
- ✓ Корректное завершение работает  
- ✓ Тот же интерфейс IPFSClient поддерживается как для внешнего режима

---

### Фаза 4: Встроенный PubSub (2-3 дня)
**Цель**: Реализовать PubSub на встроенном IPFS-узле для встроенного режима

**Задачи:**
1. Включить PubSub протокол на встроенном IPFS-узле
2. Настроить GossipSub
3. Публикация сообщений через libp2p экземпляр IPFS-узла
4. Интеграция с PubsubPublisher
5. Генерация и верификация подписей

**Новые файлы:**
```
internal/
├── pubsub/
│   ├── embedded.go      # PubSub via embedded IPFS
│   ├── publisher.go     # Message publisher
│   └── message.go       # Message format and signing
```

**Ручные тесты:**
```bash
# Test 1: PubSub enabled on embedded IPFS
./ipfs-publisher --ipfs-mode embedded
# Expect logs: "PubSub enabled on embedded IPFS node"

# Test 2: Subscribe from external IPFS
ipfs pubsub sub mdn/collections/announce &

# Test 3: Publish test message
./ipfs-publisher --ipfs-mode embedded --test-pubsub
# Expect message received in subscriber

# Test 4: Message format validation
# Capture message and verify JSON structure
# Expect all required fields present

# Test 5: Signature verification
# Provide verification script
./verify-signature.sh <pubsub_message>
# Expect: "✓ Signature valid"

# Test 6: Peer discovery for PubSub
# Check embedded node logs for PubSub peers
# Expect: "PubSub peers on topic: X"

# Test 7: Message delivery
# Start multiple subscribers
# Publish from embedded mode
# Expect: All subscribers receive message
```

**Критерии готовности:**
- ✓ PubSub включён на встроенном IPFS-узле  
- ✓ Сообщения публикуются успешно  
- ✓ Формат сообщений корректен  
- ✓ Подписи валидируются  
- ✓ Обнаружение пиров работает  
- ✓ Отдельный PubSub-узел не создаётся

---

### Фаза 5: Сканирование директорий и создание индекса (2-3 дня)
**Цель**: Сканировать директории и создавать NDJSON-индекс

**Задачи:**
1. Реализовать сканер директорий
2. Фильтрация по расширениям
3. Создать NDJSON-индекс
4. Загрузить все файлы в IPFS (учитывая режим)
5. Загрузить индекс в IPFS
6. Прогресс-бар для больших батчей

**Новые файлы:**
```
internal/
├── scanner/
│   └── scanner.go
├── index/
│   ├── manager.go
│   └── ndjson.go
```

**Ручные тесты:**
```bash
# Prepare test directory
mkdir -p ~/test-media
cp some-files.mp3 ~/test-media/
cp some-video.mkv ~/test-media/

# Test 1: Initial scan (dry-run) with external mode
./ipfs-publisher --dry-run --ipfs-mode external
# Expect: list of found files, no uploads

# Test 2: Initial scan (dry-run) with embedded mode
./ipfs-publisher --dry-run --ipfs-mode embedded
# Expect: same list of files

# Test 3: Upload all files (external mode)
./ipfs-publisher --ipfs-mode external
# Expect:
# - Progress bar with percent
# - Logs per file
# - Creation of ~/.ipfs_publisher/collection.ndjson

# Test 4: Upload all files (embedded mode)
./ipfs-publisher --ipfs-mode embedded
# Expect: same behavior as external mode

# Test 5: Check index contents
cat ~/.ipfs_publisher/collection.ndjson
# Expect lines like:
# {"id":1,"CID":"QmXxx...","filename":"file1.mp3","extension":"mp3"}

# Test 6: Index uploaded to IPFS
INDEX_CID=$(cat ~/.ipfs_publisher/state.json | jq -r .lastIndexCID)
ipfs cat $INDEX_CID
# Expect: NDJSON content

# Test 7: Filtering
touch ~/test-media/ignored.txt
./ipfs-publisher --dry-run
# Expect: ignored.txt not listed

# Test 8: Large batch (>100 files)
for i in {1..150}; do touch ~/test-media/file-$i.mp3; done
./ipfs-publisher
# Expect: working progress bar with ETA
```

**Критерии готовности:**
- ✓ Файлы из сконфигурированных директорий найдены  
- ✓ Фильтрация по расширениям работает  
- ✓ NDJSON-индекс создан корректно  
- ✓ Файлы загружены в IPFS с корректными CID  
- ✓ Индекс загружен в IPFS  
- ✓ Прогресс-бар работает  
- ✓ Работает в обоих режимах IPFS

---

### Фаза 6: IPNS и управление ключами (2 дня)
**Цель**: Сгенерировать ключи и публиковать индекс через IPNS

**Задачи:**
1. Генерация пары ключей Ed25519
2. Сохранение ключей на диск с корректными правами
3. Создать IPNS-запись (учитывая режим)
4. Обновлять IPNS при изменениях
5. Интеграция с менеджером состояния

**Новые файлы:**
```
internal/
├── keys/
│   └── manager.go
├── ipns/
│   └── manager.go
```

**Ручные тесты:**
```bash
# Test 1: Key generation on first run
rm -rf ~/.ipfs_publisher/keys
./ipfs-publisher
# Expect: creation of private.key and public.key

# Test 2: Key permissions
ls -la ~/.ipfs_publisher/keys/
# Expect: private.key with 0600, directory with 0700

# Test 3: IPNS publish (external mode)
./ipfs-publisher --ipfs-mode external
IPNS_HASH=$(cat ~/.ipfs_publisher/state.json | jq -r .ipns)
ipfs name resolve $IPNS_HASH
# Expect: index CID

# Test 4: IPNS publish (embedded mode)
./ipfs-publisher --ipfs-mode embedded
IPNS_HASH=$(cat ~/.ipfs_publisher/state.json | jq -r .ipns)
# Resolve from external node
ipfs name resolve $IPNS_HASH
# Expect: index CID (may take time to propagate via DHT)

# Test 5: Fetch index via IPNS
ipfs cat $IPNS_HASH
# Expect: NDJSON content

# Test 6: Update collection and IPNS
cp new-file.mp3 ~/test-media/
./ipfs-publisher
ipfs name resolve $IPNS_HASH
# Expect: new CID

# Test 7: Use existing keys
./ipfs-publisher
# Expect: "Loaded existing IPNS keypair"

# Test 8: IPNS in state file
cat ~/.ipfs_publisher/state.json | jq .
# Expect: ipns field with k51... hash
```

**Критерии готовности:**
- ✓ Ключи сгенерированы при первом запуске  
- ✓ Ключи загружаются при последующих запусках  
- ✓ Корректные права доступа к файлам  
- ✓ Индекс загружен в IPFS  
- ✓ IPNS-запись создана  
- ✓ IPNS указывает на индекс
- ✓ IPNS обновляется при изменениях
- ✓ Работает в обоих режимах IPFS

---

### Фаза 7: Полная интеграция PubSub для встроенного режима (1-2 дня)
**Цель**: Полный поток анонсов PubSub с использованием встроенного IPFS-узла

**Задачи:**
1. Интегрировать PubSub с обновлениями индекса
2. Реализовать периодические анонсы
3. Управление счётчиком версий
4. Подписание сообщений ключами IPNS
5. Обработка ошибок и повторные попытки

**Ручные тесты:**
```bash
# Test 1: Subscribe and monitor
ipfs pubsub sub mdn/collections/announce &

# Test 2: First publish after initial scan
./ipfs-publisher --ipfs-mode embedded
# Expect: PubSub message with version=1

# Test 3: Add file triggers publish
cp new-song.mp3 ~/test-media/
# Expect: PubSub message with version=2

# Test 4: Message content validation
# Capture last message
# Verify: version, ipns, publicKey, collectionSize, timestamp, signature

# Test 5: Periodic announcements
# Wait 60+ minutes or reduce interval in config
# Expect: Repeated messages with same version if no changes

# Test 6: Timestamp behavior
# Note timestamp from first message
# Wait for periodic announcement
# Expect: timestamp unchanged if no collection changes

# Test 7: Signature verification
./verify-signature.sh <captured_message>
# Expect: signature valid with publicKey from message

# Test 8: PubSub uses embedded IPFS
# Verify in logs that no separate PubSub node is created
# Expect: "Using embedded IPFS node for PubSub"
```

**Критерии готовности:**
- ✓ Сообщения публикуются при изменениях коллекции  
- ✓ Периодические анонсы работают  
- ✓ Формат сообщений соответствует спецификации  
- ✓ Подписи проверяемы  
- ✓ Счётчик версий увеличивается корректно  
- ✓ Поведение timestamp корректно  
- ✓ Используется встроенный libp2p IPFS-узел  
- ✓ Отдельного PubSub-узла не создаётся

---

### Фаза 7.1: Standalone PubSub для внешнего режима IPFS (2-3 дня)
**Цель**: Реализовать отдельный libp2p PubSub-узел для внешнего режима IPFS

**Контекст**: Фаза 7 реализовала PubSub для встроенного режима IPFS (используя тот же libp2p экземпляр). Теперь необходимо добавить поддержку внешнего режима, где требуется отдельный облегчённый PubSub-узел.

**Задачи:**
1. Создать standalone libp2p-узел только для PubSub
2. Реализовать GossipSub на standalone-узле
3. Настроить отдельный swarm-порт для PubSub-узла
4. Использовать те же bootstrap peers, что и IPFS
5. Включить DHT для обнаружения пиров и объявления топиков
6. Интегрировать standalone PubSub с PubsubPublisher (детекция режима)
7. Управление жизненным циклом (start/stop с приложением)
8. Мониторинг подключений пиров и состояния DHT

**Новые файлы:**
```
internal/
├── pubsub/
│   ├── standalone.go    # Standalone libp2p PubSub node (external mode)
│   ├── embedded.go      # Wrapper for embedded IPFS PubSub (embedded mode)
│   └── publisher.go     # Mode-aware publisher (updated)
```

**Ручные тесты:**
```bash
# Prepare: start external IPFS daemon
ipfs daemon &

# Test 1: Standalone PubSub node starts in external mode
./ipfs-publisher --ipfs-mode external
# Expect logs: 
# - "Starting standalone PubSub node on port 4003"
# - "PubSub node peer ID: 12D3Koo..."
# - "Connected to X bootstrap peers"

# Test 2: No standalone node in embedded mode
./ipfs-publisher --ipfs-mode embedded
# Expect logs:
# - "Using embedded IPFS node for PubSub"
# - NO logs about standalone PubSub node

# Test 3: Subscribe from external IPFS
ipfs pubsub sub mdn/collections/announce &

# Test 4: Publish from external mode
./ipfs-publisher --ipfs-mode external --test-pubsub
# Expect: message received in ipfs subscriber

# Test 5: Cross-mode communication
# Terminal 1: embedded mode
./ipfs-publisher --ipfs-mode embedded &
# Terminal 2: external mode  
./ipfs-publisher --ipfs-mode external &
# Both should see each other's announcements in logs

# Test 6: DHT peer discovery
./ipfs-publisher --ipfs-mode external
# Wait 2-3 minutes
# Check logs for DHT bootstrap and peer discovery
# Expect: "DHT routing table: X peers"

# Test 7: Standalone node resource usage
./ipfs-publisher --ipfs-mode external
ps aux | grep ipfs-publisher
# Monitor memory/CPU
# Expect: minimal overhead from standalone PubSub (~20-50MB)

# Test 8: Port configuration
# Change pubsub.standalone.swarm_port in config to 14003
./ipfs-publisher --ipfs-mode external
netstat -tuln | grep 14003
# Expect: port 14003 listening

# Test 9: Bootstrap peer connectivity
./ipfs-publisher --ipfs-mode external --config custom-bootstrap.yaml
# Custom config with specific bootstrap peers
# Expect: connects to specified peers

# Test 10: Graceful shutdown
./ipfs-publisher --ipfs-mode external
# Send SIGTERM or Ctrl+C
# Expect: 
# - "Shutting down standalone PubSub node..."
# - Clean DHT provider cleanup
# - No hanging goroutines

# Test 11: Standalone node restart on failure
# In external mode, manually kill standalone PubSub process (if detectable)
# Expect: automatic restart attempt with error logs

# Test 12: Topic subscription verification
./ipfs-publisher --ipfs-mode external
# From another terminal:
ipfs pubsub peers mdn/collections/announce
# Expect: standalone PubSub node's peer ID in list

# Test 13: Message delivery rate
# Run both modes, trigger frequent updates
# Verify both embedded and external modes receive all messages
# Expect: no message loss, consistent delivery

# Test 14: Bootstrap failure handling
# Configure invalid bootstrap peers
./ipfs-publisher --ipfs-mode external
# Expect: 
# - Error logs about bootstrap failure
# - Retry attempts
# - Application continues (degraded mode)

# Test 15: Same network verification
# External IPFS node peer ID: ipfs id
# Standalone PubSub peer ID: from logs
# Both should discover same DHT peers
# Expect: overlap in peer lists (use ipfs dht findpeer)
```

**Критерии готовности:**
- ✓ Standalone PubSub node стартует только в внешнем режиме  
- ✓ В встроенном режиме standalone-узел не создаётся  
- ✓ Отдельная идентичность пира для standalone-узла  
- ✓ Настраиваемый отдельный swarm-порт  
- ✓ Использует те же bootstrap peers, что и IPFS  
- ✓ DHT включён и функционален  
- ✓ Сообщения публикуются успешно в обоих режимах  
- ✓ Кросс-режимная доставка сообщений работает  
- ✓ Корректное завершение и очистка  
- ✓ Небольшие накладные расходы по ресурсам  
- ✓ Обнаружение пиров работает  
- ✓ Переключение режимов работает корректно

---

### Фаза 8: Наблюдатель файлов и управление состоянием (2-3 дня)
**Цель**: Обнаружение изменений в реальном времени и сохранение состояния

**Задачи:**
1. Интегрировать `fsnotify`
2. Обрабатывать события create/modify/delete/rename
3. Инкрементные обновления индекса
4. Дебаунсинг для частых изменений
5. Сохранение и восстановление состояния
6. Восстановление после крашей

**Новые файлы:**
```
internal/
├── watcher/
│   └── watcher.go
├── state/
│   └── manager.go
```

**Ручные тесты:**
```bash
# Test 1: Run in watch mode
./ipfs-publisher

# Test 2: Add new file
cp new-song.mp3 ~/test-media/
# Expect: automatic processing and PubSub update

# Test 3: Modify file
echo "updated" >> ~/test-media/existing.mp3
# Expect: reupload, index update, version increment

# Test 4: Delete file
rm ~/test-media/old-file.mp3
# Expect: removal from index, version increment

# Test 5: Rename file
mv ~/test-media/song.mp3 ~/test-media/renamed.mp3
# Expect: filename updated, id and CID preserved

# Test 6: Debounce rapid changes
for i in 1 2 3 4 5; do
  echo "change $i" >> ~/test-media/test.mp3
  sleep 0.1
done
# Expect: only one processing after 300ms debounce

# Test 7: State persistence
cat ~/.ipfs_publisher/state.json | jq .
# Expect: version, ipns, lastIndexCID, files with metadata

# Test 8: Recovery after crash
./ipfs-publisher
# Add files, kill -9 process
./ipfs-publisher
# Expect: state loaded, missing files reprocessed

# Test 9: Ignore patterns
echo "test" > ~/test-media/.hidden
echo "test" > ~/test-media/file~
# Expect: ignored in logs

# Test 10: State in both IPFS modes
# Test state persistence with external mode
# Test state persistence with embedded mode
# Expect: state format identical
```

**Критерии готовности:**
- ✓ Новые файлы обнаруживаются автоматически  
- ✓ Изменения обрабатываются корректно  
- ✓ Удаления обрабатываются  
- ✓ Переименования сохраняют id/CID  
- ✓ Дебаунс работает  
- ✓ Состояние сохраняется и загружается  
- ✓ Восстановление после краша работает  
- ✓ Игнорирование шаблонов работает  
- ✓ Работает в обоих режимах IPFS

---

### Фаза 9: Финальная доработка и граничные случаи (2-3 дня)
**Цель**: Обработать граничные случаи, улучшить UX, оптимизировать производительность

**Задачи:**
1. Улучшить сообщения об ошибках и логирование
2. Добавить полное руководство и документацию
3. Обработать все граничные случаи из PRD
4. Настроить производительность для больших коллекций
5. Проверить на утечки памяти
6. Очистка ресурсов
7. Оптимизации, специфичные для режимов

**Ручные тесты:**
```bash
# Test 1: Help and documentation
./ipfs-publisher --help
./ipfs-publisher --version

# Test 2: Init command
./ipfs-publisher --init
# Expect: config file created, keys generated

# Test 3: Special characters in filenames
touch ~/test-media/"file with spaces.mp3"
touch ~/test-media/"файл-кириллица.mp3"
touch ~/test-media/"file'with\"quotes.mp3"
./ipfs-publisher

# Test 4: Very long filenames
touch ~/test-media/"$(printf 'a%.0s' {1..300}).mp3"
./ipfs-publisher
# Expect: handled gracefully (truncated or error logged)

# Test 5: Symlinks
ln -s ~/other-dir ~/test-media/symlink
./ipfs-publisher --dry-run
# Expect: ignored or followed (document behavior)

# Test 6: Large collection stress test
for i in {1..1000}; do
  touch ~/test-media/file-$i.mp3
done
./ipfs-publisher
# Expect: completes successfully, reasonable memory usage

# Test 7: Resource monitoring during long run
./ipfs-publisher &
# Monitor with: watch -n 5 'ps aux | grep ipfs-publisher'
# Add/remove files periodically for 1 hour
# Expect: stable memory, no leaks

# Test 8: Graceful shutdown during operations
./ipfs-publisher
# While uploading files, press Ctrl+C
# Expect: "Shutting down gracefully...", state saved, lock removed

# Test 9: Mode switching
# Run with external mode
./ipfs-publisher --ipfs-mode external
# Stop, switch config to embedded
./ipfs-publisher --ipfs-mode embedded
# Expect: state preserved, continues from where it left off

# Test 10: Embedded node resource usage
# Monitor embedded node:
./ipfs-publisher --ipfs-mode embedded
# Check: memory, CPU, disk I/O, peer connections
# Expect: reasonable resource usage

# Test 11: Configuration validation
# Invalid IPFS mode
# Invalid ports (negative, out of range)
# Expect: clear error messages

# Test 12: Debug logs
./ipfs-publisher --config config.yaml
# Set logging.level: debug in config
# Expect: detailed logs for troubleshooting
```

**Критерии готовности:**
- ✓ Все граничные случаи покрыты  
- ✓ Понятные и полезные сообщения об ошибках  
- ✓ Полная документация  
- ✓ Приемлемая производительность (соответствует критериям приёмки)  
- ✓ Нет утечек памяти  
- ✓ Корректное завершение сохраняет состояние  
- ✓ Оба режима IPFS тщательно протестированы  
- ✓ Потребление ресурсов в пределах допустимого

---

### Фаза 10: Интеграционное тестирование и готовность к продакшну (1-2 дня)
**Цель**: Сквозное тестирование и финальная валидация

**Задачи:**
1. Завершить интеграционный тестовый набор
2. Протестировать все комбинации режимов
3. Долгосрочные тесты стабильности
4. Документировать процедуры деплоя
5. Создать руководство по отладке
6. Подготовить релизные артефакты

**Ручные тесты:**
```bash
# Test 1: Complete workflow (external mode)
./ipfs-publisher --ipfs-mode external --init
# Add test directory
# Wait for full cycle: scan -> upload -> IPNS -> PubSub
# Verify all components work

# Test 2: Complete workflow (embedded mode)
./ipfs-publisher --ipfs-mode embedded --init
# Same as Test 1
# Verify embedded node operates correctly

# Test 3: 24-hour stability test
./ipfs-publisher &
# Run for 24+ hours with periodic file changes
# Monitor logs, memory, CPU
# Expect: stable operation, no crashes

# Test 4: Network interruption handling
./ipfs-publisher --ipfs-mode external
# Disconnect network during operation
# Expect: errors logged, retries, recovery on reconnect

# Test 5: Embedded node crash recovery
./ipfs-publisher --ipfs-mode embedded
# Kill embedded IPFS process manually
# Expect: detected, logged, node restarted

# Test 6: Large file handling
cp large-file-2GB.mkv ~/test-media/
./ipfs-publisher
# Expect: uploads successfully without OOM

# Test 7: Concurrent changes
# Script to continuously modify files
while true; do
  echo "update" >> ~/test-media/test-$RANDOM.mp3
  sleep 1
done
./ipfs-publisher
# Expect: handles continuous changes

# Test 8: Migration between modes
# Start with external mode, populate collection
./ipfs-publisher --ipfs-mode external
# Stop, switch to embedded
./ipfs-publisher --ipfs-mode embedded
# Expect: collection state preserved, continues operation

# Test 9: Clean installation
# Fresh system, no prior config
./ipfs-publisher --init
./ipfs-publisher
# Expect: all setup automatic, works out of box

# Test 10: Production deployment simulation
# Deploy as systemd service
sudo systemctl start ipfs-publisher
sudo systemctl status ipfs-publisher
# Expect: runs as service, logs to journal
```

**Критерии готовности:**
- ✓ Все интеграционные тесты пройдены  
- ✓ 24-hour stability test успешен  
- ✓ Оба режима IPFS готовы к продакшну  
- ✓ Документация завершена  
- ✓ Руководство по отладке создано  
- ✓ Процедуры деплоя задокументированы  
- ✓ Релизные артефакты подготовлены

---

## 14. Контрольный список готовности к продакшну

### Функциональность
- [ ] Сканирование нескольких директорий
- [ ] Фильтрация по расширениям
- [ ] Загрузка файлов в IPFS (внешний режим)
- [ ] Загрузка файлов в IPFS (встроенный режим)
- [ ] Создание NDJSON-индекса
- [ ] Публикация IPNS (внешний режим)
- [ ] Публикация IPNS (встроенный режим)
- [ ] PubSub-анонсы (всегда включено)
- [ ] Мониторинг изменений в реальном времени
- [ ] Инкрементные обновления
- [ ] Сохранение и восстановление состояния
- [ ] Поддержка переключения режимов

### Интеграция с IPFS
- [ ] Внешнее подключение к IPFS работает
- [ ] Встроенный IPFS-узел успешно стартует
- [ ] Обнаружение конфликтов портов работает
- [ ] Персистентность репозитория встроенного узла
- [ ] PubSub работает на встроенном IPFS (встроенный режим)
- [ ] Standalone PubSub работает (внешний режим)
- [ ] Интеграция с DHT (в обоих режимах)
- [ ] Сборка мусора (встроенный режим)
- [ ] Подключение bootstrap-pиров (IPFS и PubSub)

### Надёжность
- [ ] Lock-файл предотвращает множественные запуски
- [ ] Корректное завершение (в обоих режимах)
- [ ] Обработка недоступности IPFS (внешний)
- [ ] Обработка сбоев встроенного узла
- [ ] Логика повторных попыток для операций
- [ ] Обработка удаления файлов во время обработки
- [ ] Корректное восстановление после краша
- [ ] Целостность состояния сохранена

### UX
- [ ] Прогресс-бар для больших коллекций
- [ ] Ясные логи с индикаторами режима
- [ ] Документация в `--help`
- [ ] `--dry-run` для тестирования
- [ ] `--init` для создания конфига
- [ ] Флаг `--ipfs-mode` для переопределения режима
- [ ] YAML-конфигурация
- [ ] Ясные ошибки при конфликтах портов
- [ ] Руководство по выбору режима

### Безопасность
- [ ] Корректные права приватных ключей (0600)
- [ ] Права директории с ключами (0700)
- [ ] Подписанные сообщения PubSub
- [ ] Валидация путей
- [ ] Санитизация имён файлов
- [ ] Меры безопасности для встроенного узла

### Производительность
- [ ] < 500MB памяти для 10k файлов (внешний)
- [ ] < 1GB памяти для 10k файлов (встроенный)
- [ ] Дебаунс для частых изменений
- [ ] Потоковая обработка индекса
- [ ] Отсутствие утечек памяти (24h+ тест)
- [ ] Допустимое потребление ресурсов встроенным узлом

### Документация
- [ ] README с руководством по выбору режима
- [ ] Документация формата конфига
- [ ] Таблица сравнения режимов IPFS
- [ ] Руководство по настройке портов
- [ ] Руководство по отладке (по режимам)
- [ ] Примеры использования (оба режима)
- [ ] Руководство по деплою
- [ ] Руководство по миграции между режимами

---

## 15. Таблица сравнения режимов IPFS

| Фича | Встроенный режим | Внешний режим |
|---------|--------------|---------------|
| **IPFS-узел** | Встроенный, полный узел | Требуется внешний демон |
| **Зависимости** | Нет | Требуется запущенный IPFS-демон |
| **Сложность настройки** | Проста (автоматически) | Средняя (ручная настройка демона) |
| **Потребление ресурсов** | Выше (~500MB-1GB) | Ниже (~200-300MB) |
| **PubSub** | На том же узле IPFS | Отдельный standalone-узел |
| **Требования по портам** | 3 порта (swarm, API, gateway) + PubSub использует тот же swarm | Порты внешнего IPFS + 1 порт для PubSub |
| **Участие в DHT** | Полный DHT-узел | Внешний IPFS + standalone PubSub DHT |
| **Доступность контента** | Высокая (свой узел) | Зависит от внешнего узла |
| **Bootstrap** | Автоматически | Унаследовано от внешнего узла |
| **Управление пиннингом** | Полный контроль | Через внешний узел |
| **Лучше для** | Продакшн, автономность | Разработка, тестирование |
| **Время старта** | ~10-30 секунд | Мгновенно (если демон уже запущен) |
| **Сетевой идентити** | Собственный peer ID | Использует внешний + standalone PubSub |
| **GC** | Настраиваемый | Управляется внешним узлом |
| **отказоустойчивость** | Самостоятельный | Зависит от демона |

---

## 16. Примеры конфигураций

### Пример 1: Встроенный режим (по умолчанию)
```yaml
ipfs:
  mode: "embedded"
  
  embedded:
    repo_path: "~/.ipfs_publisher/ipfs-repo"
    swarm_port: 4002
    api_port: 5002
    gateway_port: 8081
    
    add_options:
      pin: true
      chunker: "size-262144"
    
    gc:
      enabled: true
      interval: 86400
      
pubsub:
  topic: "mdn/collections/announce"
  announce_interval: 3600

directories:
  - "/home/user/media"

extensions:
  - "mp3"
  - "mkv"
```

### Пример 2: Внешний режим (для разработки)
```yaml
ipfs:
  mode: "external"
  
  external:
    api_url: "http://localhost:5001"
    timeout: 300
    add_options:
      nocopy: true  # Использует filestore
      pin: true
      chunker: "size-262144"
      
pubsub:
  topic: "mdn/collections/announce"
  announce_interval: 3600
  
  # Standalone PubSub node (используется во внешнем режиме)
  standalone:
    bootstrap_peers: []  # Использует стандартные bootstrap IPFS
    swarm_port: 4003
    enable_dht: true

directories:
  - "/data/media"

extensions:
  - "mp3"
  - "mkv"
  - "mp4"
```

### Пример 3: Production Embedded Mode
```yaml
ipfs:
  mode: "embedded"
  
  embedded:
    repo_path: "/var/lib/ipfs-publisher/repo"
    swarm_port: 14001
    api_port: 15001
    gateway_port: 18080
    
    add_options:
      pin: true
      chunker: "size-1048576"  # 1MB чанки для больших файлов
      raw_leaves: true
    
    gc:
      enabled: true
      interval: 43200  # 12 часов
      min_free_space: 5368709120  # 5GB

pubsub:
  topic: "production/media/announce"
  announce_interval: 1800  # 30 минут
  # Отдельного раздела standalone не нужно - встроенный IPFS обрабатывает PubSub

directories:
  - "/mnt/storage/media"

extensions:
  - "mp3"
  - "flac"
  - "mkv"
  - "mp4"

logging:
  level: "info"
  file: "/var/log/ipfs-publisher/app.log"
  max_size: 500
  max_backups: 10

behavior:
  scan_interval: 5
  batch_size: 20
  state_save_interval: 30
```
